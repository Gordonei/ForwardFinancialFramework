'''
Created on 30 October 2012

'''
import os,time,subprocess,sys,time,math
from ForwardFinancialFramework.Solvers.MonteCarlo import MonteCarlo

class MulticoreCPU_MonteCarlo(MonteCarlo.MonteCarlo):
  def __init__(self,derivative,paths,platform,reduce_underlyings=True):
    MonteCarlo.MonteCarlo.__init__(self,derivative,paths,platform,reduce_underlyings)
    self.solver_metadata["threads"] = self.platform.threads #Number of threads set by the platform
    
  def generate_identifier(self):
    return ["//%s.c Generated by Monte Carlo MulticoreCPU Solver"%self.output_file_name]
    
  def generate_libraries(self):
    #Checking that the platform source code for the derivatives and underlyings required are present
    underlying_libraries = []
    
    for u in self.underlying:
      if(not(os.path.exists("%s.c"%u.name)) or not(os.path.exists("%s.h"%u.name))): raise IOError, ("missing the source code for the underlying - %s.c or %s.h" % (u.name,u.name))
      else: underlying_libraries.append("%s.h"%u.name)
        
    derivative_libraries = []    
    for d in self.derivative:
      if(not(os.path.exists("%s.c"%d.name)) or not(os.path.exists("%s.h"%d.name))): raise IOError, ("missing the source code for the derivative - %s.c or %s.h" %  (d.name,d.name))
      else: derivative_libraries.append("%s.h"%d.name)
    
    output_list = MonteCarlo.MonteCarlo.generate_libraries(self) #Getting libraries from Parent Class
    #for u in utility_libraries: output_list.append("include \"%s\";"%(u))
    for u in underlying_libraries: output_list.append("#include \"%s\";"%u)
    for d in derivative_libraries: output_list.append("#include \"%s\";"%d)
    
    return output_list
  
  def generate_activity_thread(self):
    #Generate Path Loop Function
    output_list = []
    output_list.append("//*Path Loop Function*")
    output_list.append("void * path_loop(void* thread_arg){")
    
    ##Declare Loop Data Structures
    output_list.append("//**Loop Data Structures**")
    output_list.append("struct thread_data* temp_data;")
    output_list.append("temp_data = (struct thread_data*) thread_arg;")
    
    
    for u in self.underlying:
        index = self.underlying.index(u)
        output_list.append("%s_under_attr u_a_%d;" % (u.name,index))
        output_list.append("%s_under_var u_v_%d;" % (u.name,index))
    
    for d in self.derivative:
        index = self.derivative.index(d)
        output_list.append("%s_opt_attr o_a_%d;" % (d.name,index))
        output_list.append("%s_opt_var o_v_%d;" % (d.name,index))
    
    
    output_list.append("//**Initialising Loop Attributes*")
    
    ##Calling Init Functions
    for u in self.underlying:
        u_index = self.underlying.index(u)
        
        temp = ("%s_underlying_init("%u.name)
        for u_a in self.underlying_attributes[u_index][:-1]: temp=("%s%s_%d_%s,"%(temp,u.name,u_index,u_a))
        temp=("%s%s_%d_%s,&u_a_%d);"%(temp,u.name,u_index,self.underlying_attributes[u_index][-1],u_index))
        output_list.append(temp)
    
    for d in self.derivative:
        index = self.derivative.index(d)
        
        temp = ("%s_derivative_init("%d.name)
        for o_a in self.derivative_attributes[index][:-1]: temp=("%s%s_%d_%s,"%(temp,d.name,index,o_a))
        temp=("%s%s_%d_%s,&o_a_%d);"%(temp,d.name,index,self.derivative_attributes[index][-1],index))
        output_list.append(temp)
    
    ##Thread calculation loop
    output_list.append("//**Thread Calculation Loop**")
    
    for r in range(len(self.derivative)):
        output_list.append("double temp_total_%d=0;"%r)
    
    temp="double dummy_2"
    for d in self.derivative:
        index = self.derivative.index(d)
        for u in d.underlying:
            u_index = self.underlying.index(u)
            temp=("%s,price_%d_%d,next_time_%d_%d"%(temp,index,u_index,index,u_index))
            
    for u in self.underlying:
        u_index = self.underlying.index(u)
        temp=("%s,very_next_time_%d"%(temp,u_index))
            
    temp = "%s;"%temp
    output_list.append(temp)
    
    output_list.append("int l,k,done;")
    output_list.append("for(l=0;l<temp_data->thread_paths;l++){")
    
    output_list.append("//***Underlying and Derivative Path Initiation***")
    for u in self.underlying: 
        index = self.underlying.index(u)
        output_list.append("%s_underlying_path_init(&u_v_%d,&u_a_%d);" % (u.name,index,index))
    
    
    for d in self.derivative:
        index = self.derivative.index(d)
        output_list.append("%s_derivative_path_init(&o_v_%d,&o_a_%d);" % (d.name,index,index))
        for u in d.underlying:
            u_index = self.underlying.index(u)
            output_list.append("next_time_%d_%d = 0;"%(index,u_index))
            output_list.append("price_%d_%d = u_a_%d.current_price*exp(u_v_%d.gamma);"%(index,u_index,u_index,u_index))
    
    
    output_list.append("done=1;")
    output_list.append("while(done){")
    output_list.append("//***Derivative Path Function Calls***")
    for d in self.derivative: #calling the derivative path function
        index = self.derivative.index(d)
        output_list.append("if(")
        for u in d.underlying:
            u_index = self.underlying.index(u)
            output_list.append("(next_time_%d_%d==u_v_%d.time) && (u_v_%d.time<=o_a_%d.time_period) &&"%(index,u_index,u_index,u_index,index))
        output_list.append(" 1){")
        
        for u in d.underlying:
            u_index = self.underlying.index(u)
            output_list.append("price_%d_%d = u_a_%d.current_price*exp(u_v_%d.gamma);"%(index,u_index,u_index,u_index))
           
        output_list.append("%s_derivative_path(price_%d_%d,u_v_%d.time,&o_v_%d,&o_a_%d);" % (d.name,index,u_index,u_index,index,index)) #TODO - Some clever introspection to determine the composition of the call
        
        for u in d.underlying:
            u_index = self.underlying.index(u)
            output_list.append("next_time_%d_%d = u_v_%d.time + o_v_%d.delta_time;" % (index,u_index,u_index,index))
        output_list.append("}")
    
    
    output_list.append("//***Determining Next Times for Underlyings***")
    for u in self.underlying: 
        u_index = self.underlying.index(u)
        output_list.append("if((u_v_%d.time<o_a_%d.time_period)){"%(u_index,self.underlying_dependencies[u_index][0])) #setting very next time to the first active next time point
        output_list.append("very_next_time_%d=next_time_%d_%d;"%(u_index,self.underlying_dependencies[u_index][0],u_index))
        output_list.append("}")
        if(len(self.underlying_dependencies[u_index])>1): 
            for u_l in self.underlying_dependencies[u_index][1:]:
                output_list.append("if((u_v_%d.time<o_a_%d.time_period)&&(next_time_%d_%d<very_next_time_%d)){"%(u_index,u_l,u_l,u_index,u_index))
                output_list.append("very_next_time_%d=next_time_%d_%d;"%(u_index,u_l,u_index))
                output_list.append("}")
        
    output_list.append("//***Assesing whether loop is complete or not***")
    output_list.append("if(1")
    for d in self.derivative:
        index = self.derivative.index(d)
        for u in d.underlying:
            u_index = self.underlying.index(u)
            output_list.append(" && (u_v_%d.time>=o_a_%d.time_period)"%(u_index,index)) 
    output_list.append("){") #ending the loop if all underlyings are passed the time required by the derivatives
    output_list.append("done=0;")
    output_list.append("}")
    
    output_list.append("//***Calling Underlying Path Functions***")
    for u in self.underlying: #Calling the underlying path function
        u_index = self.underlying.index(u)
        output_list.append("if(u_v_%d.time<very_next_time_%d){"%(u_index,u_index))
        
        output_list.append("%s_underlying_path((very_next_time_%d-u_v_%d.time),&u_v_%d,&u_a_%d);" % (u.name,u_index,u_index,u_index,u_index))
        
        output_list.append("}")
    
    output_list.append("}") #End of Path Generation Loop
    
    output_list.append("//**Post path-generation calculations**")
    for d in self.derivative: #Post path-generation calculations
        index = self.derivative.index(d)
        for u in d.underlying:
            u_index = self.underlying.index(u)
            
            output_list.append("%s_derivative_payoff(price_%d_%d,&o_v_%d,&o_a_%d);"%(d.name,index,u_index,index,index))
            output_list.append("temp_total_%d += o_v_%d.value;"%(index,index))
            
    output_list.append("}")
    ##Return result to main loop
    output_list.append("//**Returning Result**")
    for d in self.derivative: output_list.append("temp_data->thread_result[%d] = temp_total_%d;"%(self.derivative.index(d),self.derivative.index(d)))
    output_list.append("}")
    
      
    return output_list
  
  def compile(self,overide=True):
    try:
      os.chdir("..")
      os.chdir(self.platform.platform_directory())
      
    except:
      os.chdir("bin")
      return "Multicore C directory doesn't exist!"
    
    if(overide or os.path.exists("%s"%self.output_file_name)):
        compile_cmd = ["g++","%s.c"%self.output_file_name]
        
        #Including all of the derivative and option classes that are used
        temp = []
        for u in self.underlying:
            if(not(u.name in temp)):
                compile_cmd.append(("%s.c" % u.name))
                temp.append(u.name)
            
            base_list = []
            self.generate_base_class_names(u.__class__,base_list)
            base_list.remove("underlying")
        
            for b in base_list:
                if(b not in temp):
                    compile_cmd.append(("%s.c" % b))
                    temp.append(b)
            
        for d in self.derivative:
            if(not(d.name in temp)):
                compile_cmd.append(("%s.c" % d.name))
                temp.append(d.name)
                
            base_list = []
            self.generate_base_class_names(d.__class__,base_list)
            base_list.remove("option")
                
            for b in base_list:
                if(b not in temp):
                    compile_cmd.append(("%s.c" % b))
                    temp.append(b) 
        
        #Including all of the non system libraries used
        #for u_l in self.non_system_libraries:
            #if(not(("%s.c" % u_l) in compile_cmd)): compile_cmd.append(("%s.c" % u_l))
            
        #Output flag
        compile_cmd.append("-o")
        compile_cmd.append(self.output_file_name)
        
        #Linking pthread library
        compile_cmd.append("-lpthread")
        
        #Optimisation Level 3
        compile_cmd.append("-O3")
        compile_cmd.append("-w")
        
        #print compile_cmd
        result = subprocess.check_output(compile_cmd)
        #print subprocess.check_output("pwd")
        os.chdir(self.platform.root_directory())
        os.chdir("bin")
        
        return result
      
    else:
      print "multicore binary already exists, using previous version. Set overide to True if you would like to force the code to be recompiled"
      os.chdir(self.platform.root_directory)
      os.chdir("bin")
        
    
  def execute(self):
    try: os.chdir("../../ForwardFinancialFramework/Solvers/MonteCarlo/multicore_c_code")
    except: print "Multicore C directory doesn't exist!"

    #print subprocess.check_output("pwd")
    run_cmd = ["./%s"%self.output_file_name]
    for k in self.solver_metadata.keys(): run_cmd.append(str(self.solver_metadata[k])) 
    
    index = 0
    for u_a in self.underlying_attributes:
        for a in u_a: run_cmd.append(str(self.underlying[index].__dict__[a])) #mirrors generation code to preserve order of variable loading
        index += 1
    
    index = 0
    for o_a in self.derivative_attributes: 
        for a in o_a: run_cmd.append(str(self.derivative[index].__dict__[a]))
        index +=1
    
    start = time.time() #Wall-time is measured by framework, not the generated application to measure overhead in calling code
    results = subprocess.check_output(run_cmd)
    finish = time.time()
    
    results = results.split("")[:-1]
    results.append((finish-start)*1000000)
    
    os.chdir("../../../bin")
    
    return results