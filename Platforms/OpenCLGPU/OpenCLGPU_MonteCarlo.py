'''
Created on 23 February 2013

'''
import os,time,subprocess,sys,time,math,pyopencl
import platform as plat
from ForwardFinancialFramework.Platforms.MulticoreCPU import MulticoreCPU_MonteCarlo
from ForwardFinancialFramework.Platforms.OpenCLGPU import OpenCLGPU
from ForwardFinancialFramework.Solvers.MonteCarlo import MonteCarlo

class OpenCLGPU_MonteCarlo(MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo):
  def __init__(self,derivative,paths,platform,reduce_underlyings=True,kernel_path_max=8,random_number_generator="mwc64x_boxmuller",floating_point_format="float"):
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.__init__(self,derivative,paths,platform,reduce_underlyings,random_number_generator=random_number_generator,floating_point_format=floating_point_format)
    self.solver_metadata["threads"] = 1 #In this context this means something different
    
    if(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): self.platform.amd_gpu_flag = False
    
    if("Darwin" in plat.system()):
      self.utility_libraries.extend(["OpenCL/opencl.h"])
      #mwc64x_path_string = "%s/../%s/%s"%(os.getcwd(),self.platform.platform_directory(),mwc64x_path_string)
    else:
      self.utility_libraries.extend(["CL/cl.hpp"])
    
    for u in self.underlying:
      if((self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat")):
	self.utility_libraries.append("gauss.h")
	break
    #self.utility_libraries.append("gauss.h")
   
    #self.utility_libraries.extend(["%s"%mwc64x_path_string])
      
    self.activity_thread_name = "opencl_montecarlo_activity_thread"
    
    self.kernel_code_string = ""
    self.cpu_seed_kernel_code_string = ""
    
    self.floating_point_format = "float"
    
    #Setting the number of points in the path, as determined by the derivatives passed to the solver
    #TODO where must this go? Probably somewhere that it will get called everytime the generate command is called
    path_points = 0
    for index,d in enumerate(self.derivative):
      if("points" in self.derivative_attributes[index]):
	if((d.points!=path_points) and path_points): raise IOError, ("For an OpenCL solver the number of path points must match")
	elif(not(path_points)): path_points = d.points
	
    if(path_points): self.solver_metadata["path_points"] = path_points
    else: self.solver_metadata["path_points"] = self.solver_metadata["default_points"]
    
    self.solver_metadata["kernel_loops"] = kernel_path_max
    self.kernel_loops = self.solver_metadata["kernel_loops"]
    
    self.solver_metadata["local_work_items"] = 1
    self.work_groups_per_compute_unit = 1
    self.set_chunk_paths()
    
    self.min_paths = self.chunk_paths #self.kernel_loops*self.solver_metadata["local_work_items"]*self.chunk_paths #i.e. the number of paths in one chunk
    
    self.header_string = "//%s.c Generated by Monte Carlo OpenCL Solver"%self.output_file_name
  
  def __setstate__(self,state):
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.__setstate__(self,state)
    self.platform = OpenCLGPU.OpenCLGPU()
  
  #def generate_identifier(self):
    #output_list = MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate_identifier(self)
    #return output_list
  
  def generate(self,override=True):
    #Generate C Host Code largely using Multicore C infrastructure
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate(self,".c",override,verbose=False)
    
    #Generate OpenCL Kernel Code
    self.kernel_code_list = self.generate_kernel()
    self.generate_source(self.kernel_code_list,".cl")
    
    #If using an AMD Platform, Generate OpenCL Kernel Code for seeding using the Host CPU
    if(self.platform.amd_gpu_flag):
      self.cpu_seed_kernel_code_list = self.generate_cpu_seed_kernel()
      self.generate_source(self.cpu_seed_kernel_code_list,"_cpu_seed.cl")
  
  def generate_activity_thread(self):
    output_list = []

    output_list.append("//*MC OpenCL Activity Thread Function*")
    output_list.append("void * %s(void* thread_arg){"%self.activity_thread_name)
    output_list.append("struct thread_data* temp_data;")
    output_list.append("temp_data = (struct thread_data*) thread_arg;")
        
    ##Declaring OpenCL Data Structures
    output_list.append("//**Creating OpenCL Infrastructure**")
    
    ###Creating OpenCL Platform
    #TODO Use PyOpenCL to find this information out
    output_list.append("//***Creating Platform***")
    output_list.append("cl_uint num_platforms;");
    output_list.append("clGetPlatformIDs(0, NULL, &num_platforms);")
    output_list.append("cl_platform_id* platform_id = (cl_platform_id*)malloc(sizeof(cl_platform_id) * num_platforms);")
    output_list.append("cl_platform_id platform = NULL;")
    output_list.append("clGetPlatformIDs(num_platforms, platform_id, &num_platforms);")
    output_list.append("for(unsigned int i = 0; i < num_platforms; ++i){")
    output_list.append("char pbuff[100];")
    output_list.append("clGetPlatformInfo(platform_id[i],CL_PLATFORM_VENDOR,sizeof(pbuff),pbuff,NULL);")
    output_list.append("platform = platform_id[i];")
    output_list.append("if(!strcmp(pbuff, \"%s\")){break;}"%(self.platform.platform_name))
    output_list.append("}")
    
    ###Creating OpenCL Context
    output_list.append("//***Creating Context***")
    output_list.append("cl_context_properties cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)platform, 0 };")
    output_list.append("cl_context context = clCreateContextFromType(cps, CL_DEVICE_TYPE_%s, NULL, NULL, NULL);"%pyopencl.device_type.to_string(self.platform.device_type))
    
    if(self.platform.amd_gpu_flag):
      ###Creating OpenCL CPU Context
      output_list.append("//***Creating CPU Context***")
      output_list.append("cl_context_properties cpu_cps[3] = { CL_CONTEXT_PLATFORM, (cl_context_properties)platform, 0 };")
      output_list.append("cl_context cpu_context = clCreateContextFromType(cpu_cps, CL_DEVICE_TYPE_CPU, NULL, NULL, NULL);")
    
    ###Creating OpenCL Device
    output_list.append("//***Creating Device***")
    output_list.append("size_t deviceListSize;")
    output_list.append("clGetContextInfo(context,CL_CONTEXT_DEVICES,0, NULL,&deviceListSize);")
    output_list.append("cl_device_id *devices = (cl_device_id *)malloc(deviceListSize);")
    output_list.append("clGetContextInfo(context, CL_CONTEXT_DEVICES, deviceListSize,devices,NULL);")
    output_list.append("cl_device_id device = devices[0];")
    
    if(self.platform.amd_gpu_flag):
      output_list.append("//***Creating CPU Device***")
      output_list.append("clGetContextInfo(cpu_context,CL_CONTEXT_DEVICES,0, NULL,&deviceListSize);")
      output_list.append("cl_device_id *cpu_devices = (cl_device_id *)malloc(deviceListSize);")
      output_list.append("clGetContextInfo(cpu_context, CL_CONTEXT_DEVICES, deviceListSize,cpu_devices,NULL);")
      output_list.append("cl_device_id cpu_device = cpu_devices[0];")
     
    ###Creating the OpenCL Program from the precompiled binary
    if('Darwin' not in plat.system()):
      output_list.append("//***Creating Program***")
      output_list.append("FILE *fp=fopen(\"%s.clbin\", \"r\");"%self.output_file_name)
      output_list.append("char *binary_buf = (char *)malloc(0x100000);")
      output_list.append("size_t binary_size = fread(binary_buf, 1, 0x100000, fp);")
      output_list.append("fclose(fp);")
      output_list.append("cl_program program = clCreateProgramWithBinary(context, 1, &device, (const size_t *)&binary_size,(const unsigned char **)&binary_buf, NULL, NULL);")
      output_list.append("clBuildProgram(program, 1, &device, NULL, NULL, NULL);")
      
      if(self.platform.amd_gpu_flag):
        ###Creating the OpenCL CPU Program from the precompiled binary
        output_list.append("//***Creating CPU Program***")
        output_list.append("FILE *cpu_fp=fopen(\"%s_cpu_seed.clbin\", \"r\");"%self.output_file_name)
        output_list.append("char *cpu_binary_buf = (char *)malloc(0x100000);")
        output_list.append("size_t cpu_binary_size = fread(cpu_binary_buf, 1, 0x100000, cpu_fp);")
        output_list.append("fclose(cpu_fp);")
        output_list.append("cl_program cpu_program = clCreateProgramWithBinary(cpu_context, 1, &cpu_device, (const size_t *)&cpu_binary_size,(const unsigned char **)&cpu_binary_buf, NULL, NULL);")
        output_list.append("clBuildProgram(cpu_program, 1, &cpu_device, NULL, NULL, NULL);")
      
    else: #The Apple OpenCL implementation doesn't seem to support binary precompilation for some reason
      output_list.append("FILE *fp;")
      output_list.append("char *source_str;")
      output_list.append("size_t source_size;")
      output_list.append("fp=fopen(\"%s.cl\",\"r\");"%self.output_file_name)
      output_list.append("source_str = (char *)malloc(0x100000);")
      output_list.append("source_size = fread(source_str, 1, 0x100000, fp);")
      output_list.append("fclose(fp);")
      output_list.append("cl_program program = clCreateProgramWithSource(context, 1, (const char **)&source_str, (const size_t *)&source_size, &ret);")
      path_string = "."
      if(self.random_number_generator=="mwc64x_boxmuller"): path_string = "mwc64x/cl"
      #elif(self.random_number_generator=="taus_boxmuller"): path_string = ""
      if("darwin" in sys.platform): path_string = "%s/%s"%(os.getcwd(),path_string)
      output_list.append("const char* buildOption =\"-I . -I %s\";"%path_string) #-x clc++
      output_list.append("ret = clBuildProgram(program, 1, &device, buildOption, NULL, NULL);")
      #output_list.append("clBuildProgram(program, 1, &device, NULL, NULL, NULL);")"""

   ###Outputing the Build Log
    """output_list.append("size_t ret_val_size;")
    output_list.append("clGetProgramBuildInfo(program, device, CL_PROGRAM_BUILD_LOG, 0, NULL, &ret_val_size);")   
    output_list.append("char build_log[ret_val_size+1];")
    output_list.append("clGetProgramBuildInfo(program,device,CL_PROGRAM_BUILD_LOG,sizeof(build_log),build_log,NULL);")
    output_list.append("build_log[ret_val_size] = '\0';")
    output_list.append("printf(\"OpenCL Build Log: %s\\n\",build_log);")"""

    ###Creating the OpenCL Kernel
    output_list.append("//***Creating Kernel Object***")
    output_list.append("cl_kernel %s_kernel = clCreateKernel(program,\"%s_kernel\",&ret);"%(self.output_file_name,self.output_file_name))
    
    if(self.platform.amd_gpu_flag): output_list.append("cl_kernel %s_cpu_seed_kernel = clCreateKernel(cpu_program,\"%s_cpu_seed_kernel\",&ret);"%(self.output_file_name,self.output_file_name))
      
    ###Creating the Memory Objects for each underlying and derivative
    #TODO Maybe there should an attribute memory object for each path, instead of one shared between all?
    output_list.append("//***Creating OpenCL Memory Objects***")
    output_list.append("cl_mem path_points_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(cl_int),NULL,NULL);")
    output_list.append("cl_mem seed_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
    output_list.append("cl_mem chunk_size_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
    output_list.append("cl_mem chunk_number_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
    
    for index,u in enumerate(self.underlying):
        output_list.append("%s_attributes u_a_%d[1];" % (u.name,index))
        output_list.append("cl_mem u_a_%d_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(%s_attributes),NULL,NULL);" % (index,u.name))
        
        
        if(self.random_number_generator=="mwc64x_boxmuller"): output_list.append("cl_mem seed_%d_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,chunk_paths*sizeof(mwc64x_state_t),NULL,NULL);" % (index))
        elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): output_list.append("cl_mem seed_%d_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,chunk_paths*sizeof(rng_state_t),NULL,NULL);" % (index))
        
        if(self.platform.amd_gpu_flag):
	  if(self.random_number_generator=="mwc64x_boxmuller"):
	    output_list.append("mwc64x_state_t *seed_%d = (mwc64x_state_t*) malloc(chunk_paths*sizeof(mwc64x_state_t));" % (index))
	    output_list.append("cl_mem seed_%d_cpu_buff = clCreateBuffer(cpu_context, CL_MEM_WRITE_ONLY,chunk_paths*sizeof(mwc64x_state_t),NULL,NULL);" % (index))
	  elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	    output_list.append("rng_state_t *seed_%d = (rng_state_t*) malloc(chunk_paths*sizeof(rng_state_t));" % (index))
	    output_list.append("cl_mem seed_%d_cpu_buff = clCreateBuffer(cpu_context, CL_MEM_WRITE_ONLY,chunk_paths*sizeof(rng_state_t),NULL,NULL);" % (index))
	    
    
    for index,d in enumerate(self.derivative):
        output_list.append("%s_attributes o_a_%d[1];" % (d.name,index))
        output_list.append("cl_mem o_a_%d_buff = clCreateBuffer(context, CL_MEM_READ_ONLY,sizeof(%s_attributes),NULL,NULL);" % (index,d.name))
        
        output_list.append("FP_t *value_%d = (FP_t*) malloc(chunk_paths*sizeof(FP_t));" % (index))
        output_list.append("cl_mem value_%d_buff = clCreateBuffer(context, CL_MEM_WRITE_ONLY,chunk_paths*sizeof(FP_t),NULL,NULL);" % (index))
        output_list.append("FP_t *value_sqrd_%d = (FP_t*) malloc(chunk_paths*sizeof(FP_t));" % (index))
        output_list.append("cl_mem value_sqrd_%d_buff = clCreateBuffer(context, CL_MEM_WRITE_ONLY,chunk_paths*sizeof(FP_t),NULL,NULL);" % (index))
        #output_list.append("%s_variables *o_v_%d = (%s_variables*) malloc(chunk_paths*sizeof(%s_variables));" % (d.name,index,d.name,d.name))
        #output_list.append("cl_mem o_v_%d_buff = clCreateBuffer(context, CL_MEM_WRITE_ONLY,chunk_paths*sizeof(%s_variables),NULL,NULL);" % (index,d.name))
    
    ##Binding the Memory Objects to the Kernel
    output_list.append("//**Setting Kernel Arguments**")
    output_list.append("clSetKernelArg(%s_kernel, 0, sizeof(cl_mem), (void *)&path_points_buff);"%(self.output_file_name))
    output_list.append("clSetKernelArg(%s_kernel, 1, sizeof(cl_mem), (void *)&seed_buff);"%(self.output_file_name))
    output_list.append("clSetKernelArg(%s_kernel, 2, sizeof(cl_mem), (void *)&chunk_size_buff);"%(self.output_file_name))
    output_list.append("clSetKernelArg(%s_kernel, 3, sizeof(cl_mem), (void *)&chunk_number_buff);"%(self.output_file_name))
    
    for index,u in enumerate(self.underlying):
      output_list.append("clSetKernelArg(%s_kernel, %d, sizeof(cl_mem), (void *)&u_a_%d_buff);"%(self.output_file_name,4 + index*2,index))
      output_list.append("clSetKernelArg(%s_kernel, %d, sizeof(cl_mem), (void *)&seed_%d_buff);"%(self.output_file_name,4 + index*2 + 1,index))
      
    for index,d in enumerate(self.derivative):
      output_list.append("clSetKernelArg(%s_kernel, %d, sizeof(cl_mem), (void *)&o_a_%d_buff);"%(self.output_file_name,4 + index*3 + 2*len(self.underlying),index))
      output_list.append("clSetKernelArg(%s_kernel, %d, sizeof(cl_mem), (void *)&value_%d_buff);"%(self.output_file_name,4 + index*3 + 1 + 2*len(self.underlying),index))
      output_list.append("clSetKernelArg(%s_kernel, %d, sizeof(cl_mem), (void *)&value_sqrd_%d_buff);"%(self.output_file_name,4 + index*3 + 2 + 2*len(self.underlying),index))
      
    if(self.platform.amd_gpu_flag):
      output_list.append("cl_mem seed_cpu_buff = clCreateBuffer(cpu_context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
      output_list.append("cl_mem chunk_size_cpu_buff = clCreateBuffer(cpu_context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
      output_list.append("cl_mem chunk_number_cpu_buff = clCreateBuffer(cpu_context, CL_MEM_READ_ONLY,sizeof(cl_uint),NULL,NULL);")
      
      output_list.append("clSetKernelArg(%s_cpu_seed_kernel, 0, sizeof(cl_mem), (void *)&seed_cpu_buff);"%(self.output_file_name))
      output_list.append("clSetKernelArg(%s_cpu_seed_kernel, 1, sizeof(cl_mem), (void *)&chunk_size_cpu_buff);"%(self.output_file_name))
      output_list.append("clSetKernelArg(%s_cpu_seed_kernel, 2, sizeof(cl_mem), (void *)&chunk_number_cpu_buff);"%(self.output_file_name))
      for index,u in enumerate(self.underlying): output_list.append("clSetKernelArg(%s_cpu_seed_kernel, %d, sizeof(cl_mem), (void *)&seed_%d_cpu_buff);"%(self.output_file_name,2*index+3,index))
        
    ##Creating the Command Queue for the Kernel
    output_list.append("//**Creating OpenCL Command Queue**")
    output_list.append("cl_command_queue command_queue = clCreateCommandQueue(context, device, 0, &ret);")
    
    if(self.platform.amd_gpu_flag): output_list.append("cl_command_queue cpu_command_queue = clCreateCommandQueue(cpu_context, cpu_device, 0, &ret);")
      
    output_list.append("//**Initialising Attributes and writing to OpenCL Memory Objects**")
    ###Writing Control Parameters
    output_list.append("cl_int *path_points_array = (cl_int*)malloc(sizeof(cl_int));")
    output_list.append("path_points_array[0] = path_points;")
    output_list.append("clEnqueueWriteBuffer(command_queue, path_points_buff, CL_TRUE, 0, sizeof(cl_int), path_points_array, 0, NULL, NULL);")
    output_list.append("cl_uint *seed_array = (cl_uint*)malloc(sizeof(cl_uint));")
    #output_list.append("time_t seed_timer;")
    #output_list.append("time(&seed_timer);")
    #output_list.append("struct tm y2k;")
    #output_list.append("y2k.tm_hour = 0; y2k.tm_min = 0; y2k.tm_sec = 0; y2k.tm_year = 100; y2k.tm_mon = 0; y2k.tm_mday = 1;")
    #output_list.append("seed_array[0] = (unsigned int)difftime(seed_timer,mktime(&y2k));") #time since 1 January, 2000
    output_list.append("seed_array[0] = (cl_uint) (temp_data->thread_rng_seed);") #(unsigned int) temp_data->thread_rng_seed
    output_list.append("clEnqueueWriteBuffer(command_queue, seed_buff, CL_TRUE, 0, sizeof(cl_uint), seed_array, 0, NULL, NULL);")
    output_list.append("cl_uint *chunk_size_array = (cl_uint*)malloc(sizeof(cl_uint));")
    output_list.append("chunk_size_array[0] = chunk_paths*kernel_loops;")
    output_list.append("clEnqueueWriteBuffer(command_queue, chunk_size_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_size_array, 0, NULL, NULL);")
    output_list.append("cl_uint *chunk_number_array = (cl_uint*)malloc(sizeof(cl_uint));")
    output_list.append("chunk_number_array[0] = 0;")
    output_list.append("clEnqueueWriteBuffer(command_queue, chunk_number_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_number_array, 0, NULL, NULL);")
    
    ###Calling Init Functions
    for u_index,u in enumerate(self.underlying):
        temp = ("%s_underlying_init("%u.name)
        for u_a in self.underlying_attributes[u_index][:-1]: temp=("%s%s_%d_%s,"%(temp,u.name,u_index,u_a))
        temp=("%s%s_%d_%s,u_a_%d);"%(temp,u.name,u_index,self.underlying_attributes[u_index][-1],u_index))   
        output_list.append(temp)
        output_list.append("clEnqueueWriteBuffer(command_queue, u_a_%d_buff, CL_TRUE, 0, sizeof(%s_attributes), u_a_%d, 0, NULL, NULL);"%(u_index,u.name,u_index))
    
    for d_index,d in enumerate(self.derivative):
        temp = ("%s_derivative_init("%d.name)
        for o_a in self.derivative_attributes[d_index][:-1]: temp=("%s%s_%d_%s,"%(temp,d.name,d_index,o_a))
        temp=("%s%s_%d_%s,o_a_%d);"%(temp,d.name,d_index,self.derivative_attributes[d_index][-1],d_index))
        output_list.append(temp)
        output_list.append("clEnqueueWriteBuffer(command_queue, o_a_%d_buff, CL_TRUE, 0, sizeof(%s_attributes), o_a_%d, 0, NULL, NULL);"%(d_index,d.name,d_index))
    
    if(self.platform.amd_gpu_flag):
      ###Writing Control Parameter
      output_list.append("clEnqueueWriteBuffer(cpu_command_queue, seed_cpu_buff, CL_TRUE, 0, sizeof(cl_uint), seed_array, 0, NULL, NULL);")
      output_list.append("clEnqueueWriteBuffer(cpu_command_queue, chunk_size_cpu_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_size_array, 0, NULL, NULL);")
      output_list.append("clEnqueueWriteBuffer(cpu_command_queue, chunk_number_cpu_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_number_array, 0, NULL, NULL);")
      output_list.append("clFinish(cpu_command_queue);")
    
    output_list.append("clFinish(command_queue);")
      
      #for index,u in enumerate(self.underlying):
        #output_list.append("clEnqueueReadBuffer(cpu_command_queue, u_v_%d_buff, CL_TRUE, 0, temp_data->thread_paths * sizeof(%s_variables),u_v_%d, 0, NULL, NULL);"%(index,u.name,index))
	#output_list.append("clFinish(command_queue);")
    
    for d in range(len(self.derivative)): 
      output_list.append("double temp_total_%d=0;"%d)
      output_list.append("double temp_value_sqrd_%d=0;"%d)
      
    ##Running the actual kernel for the first time
    if(self.platform.amd_gpu_flag):
      output_list.append("//**Run the CPU Seed kernel for the 1st 2 Times**")
      output_list.append("const size_t cpu_kernel_paths = chunk_paths;")
      output_list.append("clEnqueueNDRangeKernel(cpu_command_queue, %s_cpu_seed_kernel, (cl_uint) 1, NULL, &cpu_kernel_paths, NULL, 0, NULL, NULL);"%(self.output_file_name))
      output_list.append("clFinish(cpu_command_queue);")
      if(self.random_number_generator=="mwc64x_boxmuller"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueReadBuffer(cpu_command_queue, seed_%d_cpu_buff, CL_TRUE, 0, chunk_paths * sizeof(mwc64x_state_t),seed_%d, 0, NULL, NULL);"%(index,index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueReadBuffer(cpu_command_queue, seed_%d_cpu_buff, CL_TRUE, 0, chunk_paths * sizeof(rng_state_t),seed_%d, 0, NULL, NULL);"%(index,index))
      
      #output_list.append("clFinish(cpu_command_queue);")
      output_list.append("chunk_number_array[0] = 1;")
      output_list.append("clEnqueueWriteBuffer(cpu_command_queue, chunk_number_cpu_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_number_array, 0, NULL, NULL);")
      
      output_list.append("clFinish(cpu_command_queue);")
      output_list.append("clEnqueueNDRangeKernel(cpu_command_queue, %s_cpu_seed_kernel, (cl_uint) 1, NULL, &cpu_kernel_paths, NULL, 0, NULL, NULL);"%(self.output_file_name))
      if(self.random_number_generator=="mwc64x_boxmuller"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueWriteBuffer(command_queue, seed_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(mwc64x_state_t), seed_%d, 0, NULL, NULL);"%(index,index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueWriteBuffer(command_queue, seed_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(rng_state_t), seed_%d, 0, NULL, NULL);"%(index,index))
      #output_list.append("clFinish(command_queue);")
    
    output_list.append("//**Run the kernel for the 1st Time**")
    output_list.append("const size_t kernel_paths = chunk_paths;")
    output_list.append("const size_t local_kernel_paths = local_work_items;")
    output_list.append("clEnqueueNDRangeKernel(command_queue, %s_kernel, (cl_uint) 1, NULL, &kernel_paths, &local_kernel_paths, 0, NULL, NULL);"%(self.output_file_name))
    
    output_list.append("unsigned int chunks = ceil(((FP_t)temp_data->thread_paths)/chunk_paths/kernel_loops);")
    #output_list.append("chunks = !(chunks)? 1: chunks;")
    #output_list.append("chunks = (temp_data->thread_paths%%(chunk_paths*kernel_loops))? chunks : chunks;")
    
    #output_list.append("for(unsigned int j=1;j<(chunks+1);++j){")
    output_list.append("unsigned int j = 1;")
    for index,d in enumerate(self.derivative):
      output_list.append("long long remaining_paths_%d = temp_data->thread_paths;"%index)
      
    output_list.append("while(")
    for index,d in enumerate(self.derivative): output_list.append("remaining_paths_%d>0 &&"%index)
    output_list.append("1){")
    output_list.append("clFinish(command_queue);")
    output_list.append("chunk_number_array[0] = j;")
    
    if(self.platform.amd_gpu_flag):
      output_list.append("clFinish(cpu_command_queue);")
      if(self.random_number_generator=="mwc64x_boxmuller"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueReadBuffer(cpu_command_queue, seed_%d_cpu_buff, CL_TRUE, 0, chunk_paths * sizeof(mwc64x_state_t),seed_%d, 0, NULL, NULL);"%(index,index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueReadBuffer(cpu_command_queue, seed_%d_cpu_buff, CL_TRUE, 0, chunk_paths * sizeof(rng_state_t),seed_%d, 0, NULL, NULL);"%(index,index))
      output_list.append("clFinish(cpu_command_queue);")
      
      output_list.append("clEnqueueWriteBuffer(cpu_command_queue, chunk_number_cpu_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_number_array, 0, NULL, NULL);")
      output_list.append("clFinish(cpu_command_queue);")
      
      output_list.append("clEnqueueNDRangeKernel(cpu_command_queue, %s_cpu_seed_kernel, (cl_uint) 1, NULL, &cpu_kernel_paths, NULL, 0, NULL, NULL);"%(self.output_file_name))
      if(self.random_number_generator=="mwc64x_boxmuller"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueWriteBuffer(command_queue, seed_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(mwc64x_state_t), seed_%d, 0, NULL, NULL);"%(index,index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	for index,u in enumerate(self.underlying): output_list.append("clEnqueueWriteBuffer(command_queue, seed_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(rng_state_t), seed_%d, 0, NULL, NULL);"%(index,index))
      #output_list.append("clFinish(command_queue);")
    
    ##Reading the Results out
    output_list.append("//**Reading the results**")
    for d_index,d in enumerate(self.derivative):
        output_list.append("clEnqueueReadBuffer(command_queue, value_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(FP_t),value_%d, 0, NULL, NULL);"%(d_index,d_index))
        output_list.append("clEnqueueReadBuffer(command_queue, value_sqrd_%d_buff, CL_TRUE, 0, chunk_paths * sizeof(FP_t),value_sqrd_%d, 0, NULL, NULL);"%(d_index,d_index))
    
    output_list.append("clEnqueueWriteBuffer(command_queue, chunk_number_buff, CL_TRUE, 0, sizeof(cl_uint), chunk_number_array, 0, NULL, NULL);")
    output_list.append("clFinish(command_queue);")
    
    ##Running the actual kernel
    output_list.append("//**Run the kernel**")
    output_list.append("clEnqueueNDRangeKernel(command_queue, %s_kernel, (cl_uint) 1, NULL, &kernel_paths, &local_kernel_paths, 0, NULL, NULL);"%(self.output_file_name))
    
    output_list.append("//**Post-Kernel Calculations**")
    output_list.append("for(int i=0;i<chunk_paths;i++){")
    for index,d in enumerate(self.derivative):
      #output_list.append("printf(\"%%f\\n\",o_a_%d[0].time_period);"%index)
      #output_list.append("printf(\"%%d:%%d - %%f - %%f\\n\",j,i,value_%d[i],value_sqrd_%d[i]);"%(index,index))
      output_list.append("if((remaining_paths_%d>0) && !(isnan(value_%d[i])||isinf(value_%d[i]))){"%(index,index,index))
      output_list.append("temp_total_%d += value_%d[i];"%(index,index))
      output_list.append("temp_value_sqrd_%d += value_sqrd_%d[i];"%(index,index))
      output_list.append("remaining_paths_%d = remaining_paths_%d - kernel_loops;"%(index,index))
      output_list.append("}")
      #output_list.append("else{printf(\"%d-%%d is a nan!\\n\",i);}"%index)
    output_list.append("}")
    
    output_list.append("j++;")
    output_list.append("}")
    output_list.append("clFinish(command_queue);")
    if(self.platform.amd_gpu_flag): output_list.append("clFinish(cpu_command_queue);")
    
    output_list.append("//**Returning Result**")
    #output_list.append("printf(\"path_points_array[0]=%d\\n\",path_points_array[0]);")
    #output_list.append("FP_t scaling_factor = (((FP_t)temp_data->thread_paths)/(chunk_paths*kernel_loops*chunks));")
    for index,d in enumerate(self.derivative):
      output_list.append("temp_data->thread_result[%d] = temp_total_%d;"%(index,index)) #*scaling_factor
      output_list.append("temp_data->thread_result_sqrd[%d] = temp_value_sqrd_%d;"%(index,index)) #*scaling_factor
    
    output_list.append("//**Cleaning up**")
    output_list.append("clReleaseKernel(%s_kernel);"%self.output_file_name)
    output_list.append("clReleaseProgram(program);")
    output_list.append("clReleaseCommandQueue(command_queue);")
    output_list.append("clReleaseContext(context);")
    output_list.append("clReleaseMemObject(path_points_buff);")
    output_list.append("clReleaseMemObject(seed_buff);")
    output_list.append("clReleaseMemObject(chunk_size_buff);")
    output_list.append("clReleaseMemObject(chunk_number_buff);")
    
    for index,u in enumerate(self.underlying):
        output_list.append("clReleaseMemObject(u_a_%d_buff);" % (index))
        output_list.append("clReleaseMemObject(seed_%d_buff);" % (index))
        
    for index,d in enumerate(self.derivative):
	output_list.append("clReleaseMemObject(o_a_%d_buff);" % (index))
        output_list.append("clReleaseMemObject(value_%d_buff);" % (index))
        output_list.append("clReleaseMemObject(value_sqrd_%d_buff);" % (index))
    
    output_list.append("}")
    
    return output_list
  
  def generate_libraries(self):
    output_list = MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate_libraries(self)
    
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    for u in self.underlying: 
      if(not(os.path.exists("../../MulticoreCPU/multicore_c_code/%s.c"%u.name)) or not(os.path.exists("../../MulticoreCPU/multicore_c_code/%s.h"%u.name))): raise IOError, ("missing the source code for the underlying - ../../MulticoreCPU/multicore_c_code/%s.c or ../../MulticoreCPU/multicore_c_code/%s.h" % (u.name,u.name))
      else:
	output_list.remove("#include \"%s.h\";"%u.name)
	output_list.append("#include \"../../MulticoreCPU/multicore_c_code/%s.h\""%u.name)
	
    os.chdir(self.platform.root_directory())
    os.chdir("bin")
    
    return output_list
  
  def generate_kernel(self):
    output_list = []
    
    #Changing to code generation directory for underlying and derivatives
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    if(self.platform.amd_gpu_flag): output_list.append("#define AMD_GPU")
    #elif("darwin" not in sys.platform): output_list.append("#include <sys/times.h>")
    #else: output_list.append("#include \"mach/mach_time.h\"")
    
    output_list.append("#ifndef M_PI")
    output_list.append("#define M_PI 3.141592653589793238")
    output_list.append("#endif")
    #output_list.append("#define %s"%self.platform.name.upper())
    output_list.append("#define FP_t %s"%self.floating_point_format)
    if(self.floating_point_format.lower()=="double"):
      output_list.append("#if defined(cl_amd_fp64)")
      output_list.append("#pragma OPENCL EXTENSION cl_amd_fp64 : enable")
      output_list.append("#elif defined(cl_khr_fp64)")
      output_list.append("#pragma OPENCL EXTENSION cl_khr_fp64 : enable")
      output_list.append("#endif")
      
    path_string = ""
    if(self.random_number_generator=="mwc64x_boxmuller"): path_string = "mwc64x/cl/mwc64x.cl"
    elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): path_string = "gauss.c"
    if('darwin' in sys.platform): path_string = "%s/%s"%(os.getcwd(),path_string)
    output_list.append("#include \"%s\""%path_string)
    
    #Checking that the source code for the derivative and underlying required is avaliable
    for u in self.underlying: 
      if(not(os.path.exists("%s.c"%u.name)) or not(os.path.exists("%s.h"%u.name))): raise IOError, ("missing the source code for the underlying - %s.c or %s.h" % (u.name,u.name))
      elif("#include \"%s.c\""%u.name not in output_list): output_list.append("#include \"%s.c\""%u.name) #Include source code body files as it all gets compiled at once
        
    #for d in self.derivative:
      #if(not(os.path.exists("%s.c"%d.name)) or not(os.path.exists("%s.h"%d.name))): raise IOError, ("missing the source code for the derivative - %s.c or %s.h" %  (d.name,d.name))
      #else: output_list.append("#include \"%s.c\""%d.name) #Include source code body files as it all gets compiled at once
    
    temp = []
    for d in self.derivative:
            if(not(d.name in temp)):
		if(not(os.path.exists("%s.c"%d.name)) or not(os.path.exists("%s.h"%d.name))): raise IOError, ("missing the source code for the derivative - %s.c or %s.h" %  (d.name,d.name))
                
                output_list.append("#include \"%s.c\"" % d.name)
                temp.append(d.name)
                
		base_list = []
		self.generate_base_class_names(d.__class__,base_list)
		#base_list.remove("option")
                
		for b in base_list:
		    if(b not in temp):
			if(not(os.path.exists("%s.c"%b)) or not(os.path.exists("%s.h"%b))): raise IOError, ("missing the source code for the derivative - %s.c or %s.h" %  (b,b))
			output_list.append("#include \"%s.c\"" % b)
			temp.append(b)
                    
    #Leaving code generation directory
    os.chdir(self.platform.root_directory())
    os.chdir("bin")
    
    output_list.append("kernel void %s_kernel("%self.output_file_name)
    output_list.append("\tconstant int *path_points,")
    output_list.append("\tglobal uint *seed,")
    output_list.append("\tglobal uint *chunk_size,") #constant
    output_list.append("\tglobal uint *chunk_number,") #constant
    for index,u in enumerate(self.underlying):
      output_list.append("\tglobal %s_attributes *u_a_%d,"%(u.name,index)) #constant
      if(self.random_number_generator=="mwc64x_boxmuller"): output_list.append("\tglobal mwc64x_state_t *seed_%d,"%(index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): output_list.append("\tglobal rng_state_t *seed_%d,"%(index))
      
    for index,d in enumerate(self.derivative):
      output_list.append("\tglobal %s_attributes *o_a_%d,"%(d.name,index)) #constant
      output_list.append("\tglobal FP_t *value_%d,"%(index))
      output_list.append("\tglobal FP_t *value_sqrd_%d,"%(index))
      
    output_list[-1] = "%s){" % (output_list[-1][:-1])
    
    output_list.append("//**getting unique ID**")
    output_list.append("int i = get_global_id(0);")
    
    """if (not(self.platform.amd_gpu_flag) and ("darwin" not in sys.platform)):
      output_list.append("//**Generating time offset**")
      output_list.append("ulong time;")
      output_list.append("struct tms buffer;")
      output_list.append("times(&buffer);")
      output_list.append("time = (ulong)(buffer.tms_utime + buffer.tms_stime);")
    elif(not(self.platform.amd_gpu_flag) and ("darwin" in sys.platform)):
      output_list.append("//**Generating time offset**")
      output_list.append("ulong time;")
      output_list.append("time = 0;")
      #output_list.append("time = (ulong)mach_absolute_time();")"""
    
    output_list.append("//**reading parameters from host**")
    output_list.append("int local_path_points=path_points[0];")
    output_list.append("uint local_chunk_size = chunk_size[0];")
    output_list.append("uint local_chunk_number = chunk_number[0];")
    output_list.append("uint local_seed = seed[0];")
      
    output_list.append("//**Creating Kernel variables and Copying parameters from host**")
    for index,u in enumerate(self.underlying):
      output_list.append("%s_attributes temp_u_a_%d = u_a_%d[0];"%(u.name,index,index))
      output_list.append("%s_variables temp_u_v_%d;"%(u.name,index))
      
      if(self.random_number_generator=="mwc64x_boxmuller"):
	if(self.platform.amd_gpu_flag and ("heston_underlying" in u.name or "black_scholes_underlying" in u.name)): 
	  output_list.append("temp_u_v_%d.rng_state.x = seed_%d[i].x;"%(index,index))
	  output_list.append("temp_u_v_%d.rng_state.c = seed_%d[i].c;"%(index,index))
	elif("heston_underlying" in u.name or "black_scholes_underlying" in u.name):
	  output_list.append("MWC64X_SeedStreams(&(temp_u_v_%d.rng_state),local_seed + 4096*2*local_chunk_size*(local_chunk_number*%d + %d),4096*2);"%(index,len(self.underlying),index))
	  
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	if(self.platform.amd_gpu_flag and ("heston_underlying" in u.name or "black_scholes_underlying" in u.name)): 
	  output_list.append("temp_u_v_%d.rng_state.s1 = seed_%d[i].s1;"%(index,index))
	  output_list.append("temp_u_v_%d.rng_state.s2 = seed_%d[i].s2;"%(index,index))
	  output_list.append("temp_u_v_%d.rng_state.s3 = seed_%d[i].s3;"%(index,index))
	  output_list.append("temp_u_v_%d.rng_state.offset = seed_%d[i].offset;"%(index,index))
	
	elif("heston_underlying" in u.name or "black_scholes_underlying" in u.name):
	  output_list.append("temp_u_v_%d.rng_state.s1 = %d + local_chunk_number*local_chunk_size + 2;"%(index,index)) #%d + local_chunk_number*local_chunk_size +
	  output_list.append("temp_u_v_%d.rng_state.s2 = %d + local_chunk_number*local_chunk_size + 8;"%(index,index)) #%d + local_chunk_number*local_chunk_size +
	  output_list.append("temp_u_v_%d.rng_state.s3 = local_seed + %d + local_chunk_number*local_chunk_size + 16;"%(index,index)) #local_seed + %d + 1 + local_chunk_number*local_chunk_size +
	  output_list.append("temp_u_v_%d.rng_state.offset = 0;"%(index))
	   
      
	
	  #if("darwin" not in sys.platform): output_list.append("MWC64X_SeedStreams(&(temp_u_v_%d.rng_state),(chunk_size[0]*chunk_number[0]+1)*time,%d*4096*2*i);"%(index,self.kernel_loops))
        #else: output_list.append("MWC64X_SeedStreams(&(temp_u_v_%d.rng_state),(chunk_size[0]*chunk_number[0]+1)*local_seed,%d*4096*2*i);"%(index,self.kernel_loops))
    
      output_list.append("FP_t spot_price_%d,time_%d;"%(index,index))
    
    for index,d in enumerate(self.derivative):
      output_list.append("%s_attributes temp_o_a_%d = o_a_%d[0];"%(d.name,index,index))
      output_list.append("%s_variables temp_o_v_%d;"%(d.name,index))
      output_list.append("FP_t temp_value_%d = 0.0;"%index)
      output_list.append("FP_t temp_value_sqrd_%d = 0.0;"%index)
    
    output_list.append("for(int k=0;k<%d;++k){"%self.kernel_loops)
    
    output_list.append("//**Initiating the Path and creating path variables**")
    for index,u in enumerate(self.underlying):
        output_list.append("%s_underlying_path_init(&temp_u_v_%d,&temp_u_a_%d);" % (u.name,index,index))
        
        output_list.append("spot_price_%d = temp_u_a_%d.current_price*native_exp(temp_u_v_%d.gamma);"%(index,index,index))
        output_list.append("time_%d = temp_u_v_%d.time;"%(index,index))
    
    for index,d in enumerate(self.derivative):
        output_list.append("%s_derivative_path_init(&temp_o_v_%d,&temp_o_a_%d);" % (d.name,index,index))
        
        #If a derivative doesn't have the number of path points specified, its delta time needs to be set to reflect what is the default points or that of the other derivatives
	if("points" not in self.derivative_attributes[index]): output_list.append("temp_o_v_%d.delta_time = temp_o_a_%d.time_period/local_path_points;"%(index,index))
	
    output_list.append("//**Running the path**")
    output_list.append("for(int j=0;j<local_path_points;++j){")
    
    temp_underlying = self.underlying[:]
    for index,d in enumerate(self.derivative):
      for u in d.underlying: #Calling derivative and underlying path functions
	u_index = self.underlying.index(u)
	output_list.append("%s_derivative_path(spot_price_%d,time_%d,&temp_o_v_%d,&temp_o_a_%d);" % (d.name,u_index,u_index,index,index))
	
	if(u in temp_underlying):
	  output_list.append("%s_underlying_path(temp_o_v_%d.delta_time,&temp_u_v_%d,&temp_u_a_%d);" % (u.name,index,u_index,u_index))
	  temp_underlying.remove(u)
	  output_list.append("spot_price_%d = temp_u_a_%d.current_price*native_exp(temp_u_v_%d.gamma);"%(u_index,u_index,u_index))
	  output_list.append("time_%d = temp_u_v_%d.time;"%(u_index,u_index))
    
    output_list.append("}") #End of Path For Loop
    
    output_list.append("//**Calculating payoff(s)**")
    for index,d in enumerate(self.derivative):
      for u in d.underlying:
	u_index = self.underlying.index(u)
	output_list.append("%s_derivative_payoff(spot_price_%d,&temp_o_v_%d,&temp_o_a_%d);"%(d.name,u_index,index,index))
	output_list.append("temp_value_%d += temp_o_v_%d.value;"%(index,index))
        output_list.append("temp_value_sqrd_%d += native_powr(temp_o_v_%d.value,2);"%(index,index))
	
    output_list.append("}") #End of Kernel For Loop
    
    output_list.append("//**Copying the result to global memory**")
    for index,d in enumerate(self.derivative):
      output_list.append("value_%d[i] = temp_value_%d;"%(index,index))
      output_list.append("value_sqrd_%d[i] = temp_value_sqrd_%d;"%(index,index))
    
    output_list.append("}") #End of Kernel
    
    #Turning output list into output string
    output_string = output_list[0]
    for line in output_list[1:]: output_string = "%s\n%s"%(output_string,line)
    output_string = "%s\n"%(output_string) #Adding newline to end of file
    self.kernel_code_string = output_string
    
    return output_list
      
  def generate_cpu_seed_kernel(self):
    output_list = []
    
    #Changing to code generation directory for underlying and derivatives
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    output_list.append("#define %s"%self.platform.name.upper())
    output_list.append("#define FP_t %s"%self.floating_point_format)
    
    #output_list.append("#include <sys/times.h>")
    
    path_string = ""
    if(self.random_number_generator=="mwc64x_boxmuller"): path_string = "mwc64x/cl/mwc64x.cl"
    elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): path_string = "gauss.c"
    
    if("darwin" in sys.platform): path_string = "%s/%s"%(os.getcwd(),path_string)
    output_list.append("#include \"%s\""%path_string)
    
    #Checking that the source code for the derivative and underlying required is avaliable
    for u in self.underlying: 
      if(not(os.path.exists("%s.c"%u.name)) or not(os.path.exists("%s.h"%u.name))): raise IOError, ("missing the source code for the underlying - %s.c or %s.h" % (u.name,u.name))
      elif("#include \"%s.c\""%u.name not in output_list): output_list.append("#include \"%s.c\""%u.name) #Include source code body files as it all gets compiled at once
                        
    #Leaving code generation directory
    os.chdir(self.platform.root_directory())
    os.chdir("bin")
    
    output_list.append("kernel void %s_cpu_seed_kernel("%self.output_file_name)
    output_list.append("\tglobal uint *seed,")
    output_list.append("\tglobal uint *chunk_size,")
    output_list.append("\tglobal uint *chunk_number,")
    for index,u in enumerate(self.underlying):
      #output_list.append("\tlocal mwc64x_state_t *local_seed_%d,"%(index))
      if(self.random_number_generator=="mwc64x_boxmuller"): output_list.append("\tglobal mwc64x_state_t *seed_%d,"%(index))
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"): output_list.append("\tglobal rng_state_t *seed_%d,"%(index))
      
    output_list[-1] = "%s){" % (output_list[-1][:-1])
    
    output_list.append("//**getting unique ID**")
    output_list.append("int i = get_global_id(0);")
    #output_list.append("int j = get_local_id(0);")
    
    output_list.append("uint local_seed = seed[0];")
    output_list.append("uint local_chunk_size = chunk_size[0];")
    output_list.append("uint local_chunk_number = chunk_number[0];")
    
    """output_list.append("//**Generating time offset**")
    output_list.append("ulong time;")
    output_list.append("struct tms buffer;")
    output_list.append("times(&buffer);")
    output_list.append("time = (ulong)(buffer.tms_utime + buffer.tms_stime);")"""
    
    output_list.append("//**Initiating the Path for each underlying**")
    for i,u in enumerate(self.underlying):
      if(self.random_number_generator=="mwc64x_boxmuller"): 
	output_list.append("mwc64x_state_t temp_seed_%d;"%(i)) 
        output_list.append("MWC64X_SeedStreams(&(temp_seed_%d),local_seed + 4096*2*local_chunk_size*(local_chunk_number*%d + %d),4096*2);"%(i,len(self.underlying),i))
        
        output_list.append("seed_%d[i].x = temp_seed_%d.x;"%(i,i))
        output_list.append("seed_%d[i].c = temp_seed_%d.c;"%(i,i))
        
      elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
	output_list.append("rng_state_t temp_seed_%d;"%i)
	output_list.append("for(int j=0;j<100;++j) __random32(&temp_seed_%d);"%i)
	
	output_list.append("seed_%d.s1 = temp_seed_%d.s1;")
	output_list.append("seed_%d.s2 = temp_seed_%d.s2;")
	output_list.append("seed_%d.s3 = temp_seed_%d.s3;")
	output_list.append("seed_%d.offset = temp_seed_%d.offset;")
        
    output_list.append("}") #End of Kernel
    
    #Turning output list into output string
    output_string = output_list[0]
    for line in output_list[1:]: output_string = "%s\n%s"%(output_string,line)
    output_string = "%s\n"%(output_string) #Adding newline to end of file
    self.cpu_seed_kernel_code_string = output_string
    
    return output_list
  
  def generate_variable_declaration(self):
    output_list = MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate_variable_declaration(self)
    if(self.random_number_generator=="mwc64x_boxmuller"): output_list.append("typedef struct{ cl_uint x; cl_uint c; } mwc64x_state_t;")
  
    return output_list
  
  def compile(self,override=True,cleanup=True,debug=False):
    compile_flags = ["-lOpenCL","-I/opt/AMDAPP/include","-fpermissive"]
    if(debug): compile_flags.append("-ggdb")
    if("darwin" in sys.platform):
      compile_flags.remove("-lOpenCL")
      compile_flags.append("-framework")
      compile_flags.append("OpenCL")
    result = MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.compile(self,override,compile_flags,debug) #Compiling Host C Code
      
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    
    opencl_compile_flags = ""
    path_string = ""
    if(self.random_number_generator=="mwc64x_boxmuller"):
      #path_string = ""
      opencl_compile_flags = "%s -DMWC64X_BOXMULLER"%opencl_compile_flags
    
    elif(self.random_number_generator=="taus_boxmuller" or self.random_number_generator=="taus_ziggurat"):
      #path_string = ""
      opencl_compile_flags = "%s -DTAUS_BOXMULLER"%opencl_compile_flags
    
    #if("darwin" in sys.platform): path_string = "%s/%s"%(os.getcwd(),path_string)
    path_string = os.getcwd()
    #else: path_string = "%s/%s"%(os.getcwd(),path_string)
    
    opencl_compile_flags = "-DOPENCL_GPU -I%s %s"% (path_string,opencl_compile_flags)
    #else: opencl_compile_flags = "-I . %s"% (opencl_compile_flags)
    self.program = pyopencl.Program(self.platform.context,self.kernel_code_string).build([opencl_compile_flags]) #Creating OpenCL program based upon Kernel
    
    preferred_wg_size_multiple = self.program.all_kernels()[0].get_work_group_info(pyopencl.kernel_work_group_info.PREFERRED_WORK_GROUP_SIZE_MULTIPLE,self.platform.device)
    max_wg_size = self.program.all_kernels()[0].get_work_group_info(pyopencl.kernel_work_group_info.WORK_GROUP_SIZE,self.platform.device)
    num_wg = math.floor(max_wg_size/preferred_wg_size_multiple/self.work_groups_per_compute_unit)
    
    self.solver_metadata["local_work_items"] = max([preferred_wg_size_multiple*num_wg,1])
    self.set_chunk_paths()
    
    binary_kernel = self.program.get_info(pyopencl.program_info.BINARIES)[0] #Getting the binary code for the OpenCL code
    binary_kernel_file = open("%s.clbin"%self.output_file_name,"w") #Writing the binary code to a file to be read by the Host C Code
    binary_kernel_file.write(binary_kernel)
    binary_kernel_file.close()
    
    #If using an AMD Platform, Compile OpenCL Kernel Code for seeding using the Host CPU
    if(self.platform.amd_gpu_flag):
      self.cpu_seed_program = pyopencl.Program(self.platform.cpu_context,self.cpu_seed_kernel_code_string).build(["-I . -I %s"%path_string]) #Creating OpenCL program based upon Kernel
      binary_kernel = self.cpu_seed_program.get_info(pyopencl.program_info.BINARIES)[0] #Getting the binary code for the OpenCL code
      binary_kernel_file = open("%s_cpu_seed.clbin"%self.output_file_name,"w") #Writing the binary code to a file to be read by the Host C Code
      binary_kernel_file.write(binary_kernel)
      binary_kernel_file.close()
    
    os.chdir(self.platform.root_directory())
    os.chdir("bin")
      
    return result
 
  def execute(self,cleanup=False,debug=False):
    self.set_chunk_paths() #just making sure this has been set...
    
    while(self.solver_metadata["paths"]<(self.solver_metadata["chunk_paths"]*self.solver_metadata["kernel_loops"])): #if one chunk is bigger than the total number of paths
      if(self.work_groups_per_compute_unit>=2):
        self.work_groups_per_compute_unit = self.work_groups_per_compute_unit/2
        self.set_chunk_paths()
      elif(self.kernel_loops>=2):
        self.kernel_loops = self.kernel_loops/2
        self.set_chunk_paths()
      else: #well, we've tried everything...
        break
      
    result = MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.execute(self,cleanup,debug)
  
    return result
  
  def set_chunk_paths(self):
    self.solver_metadata["chunk_paths"] = self.solver_metadata["local_work_items"]*self.platform.device.max_compute_units*self.work_groups_per_compute_unit
    
    if(0<self.platform.threads<self.solver_metadata["chunk_paths"]): self.solver_metadata["chunk_paths"] = self.platform.threads
    if(0<self.platform.threads<self.solver_metadata["local_work_items"]): self.solver_metadata["local_work_items"] = self.platform.threads
    
    self.chunk_paths = self.solver_metadata["chunk_paths"]
    
  def generate_pickle(self,file_name=""):
      self.platform.platform = None
      self.platform.device_type = None
      self.platform.device = None
      self.platform.context = None
      self.platform.cpu_device = None
      self.platform.cpu_context = None
      self.program = None
      self.cpu_seed_program = None
      MonteCarlo.MonteCarlo.generate_pickle(self,file_name)
