/*
 * Copyright (c) 2009-2012 Xilinx, Inc.  All rights reserved.
 *
 * Xilinx, Inc.
 * XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
 * COURTESY TO YOU.  BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
 * ONE POSSIBLE   IMPLEMENTATION OF THIS FEATURE, APPLICATION OR
 * STANDARD, XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION
 * IS FREE FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE
 * FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
 * XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
 * THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO
 * ANY WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
 * FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 */

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */
#define VIVADO_CORE_ADDR 0x43C00000
#define MULTICORE_CPU


#include "vivado_core.h"
#include "xvivado_activity_thread.h"
#include <stdio.h>
#include "platform.h"
#include "math.h"
#include "pthread.h"
#include "stdlib.h"
#include "stdio.h"
#include "time.h"
//#include "sys/resource.h"
#include "unistd.h"
#include "string.h"
#include "gauss.h"
#include "vivado_core.h"
#include "underlying.h"
#include "option.h"

void vivado_activity_thread_hw(standard_underlying_attributes *kernel_u_a_0,standard_derivative_attributes *kernel_o_a_0,rng_state_t *seed_0,unsigned int thread_result_addr);

//*Intermediate and Communication Variables*
FP_t discount_0_0;
FP_t option_price_0;
FP_t option_price_0_confidence_interval;
static FP_t underlying_0_rfir;
static FP_t underlying_0_current_price;
static FP_t option_0_time_period;
static FP_t option_0_call;
static FP_t option_0_strike_price;
static int paths;
static int default_points;
static int path_points;
static int threads;
static int instance_paths;
static int rng_seed;
int thread_paths,i,j;
struct thread_data{
	int thread_paths;
	unsigned int thread_rng_seed;
	double *thread_result;
	double *thread_result_sqrd;
	};

//*Performance Monitoring Variables*
FP_t setup_time,activity_time;
struct timespec start, setup_end, end;
int ret,ret_2;
typedef struct{
	underlying_attributes u_a_0;
	option_attributes o_a_0;
	} kernel_data;


int main()
{
    init_platform();

	//***Solver Metadata***
    paths = 1000;
	default_points = 10;
	path_points = 10;
	threads = 1;
	instance_paths = 1000;
	rng_seed = 2641278369;

	//***Underlying Attributes***
	underlying_0_rfir = 0.1;
	underlying_0_current_price = 100;

	//***Derivative Attributes***
	option_0_time_period = 1.0;
	option_0_call = 1.0;
	option_0_strike_price = 100;

	//**Calculating Discount Factor**
	discount_0_0 = exp(-underlying_0_rfir*option_0_time_period);

	//**Creating Thread Variables**
//	thread_paths = paths/threads;
//	pthread_t pthreads[threads];
//	struct thread_data temp_data[threads];
	for(i=0;i<threads;i++){
		temp_data[i].thread_result=(double*)malloc(1*sizeof(FP_t));
		temp_data[i].thread_result_sqrd=(double*)malloc(1*sizeof(FP_t));
		}
//	pthread_attr_t attr;
//	pthread_attr_init(&attr);
//	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	//**Packing up data and passing to threads**
	int i;
	for(i=0;i<threads;i++){ //Generating Threads
		temp_data[i].thread_paths = thread_paths;
		temp_data[i].thread_rng_seed = rng_seed + i*thread_paths*1;
		if(i==(threads-1)){ //If final thread, allocating any remaining paths to it (i.e. PATHS%THREADS!=0)
			temp_data[i].thread_paths += paths%threads;
			}
		//pthread_create(&pthreads[i],&attr,multicore_montecarlo_activity_thread,&temp_data[i]);

		}
//	clock_gettime(CLOCK_MONOTONIC,&setup_end);

	//**Waiting for threads to join**
	void *status;
	option_price_0 = 0;
	option_price_0_confidence_interval = 0;
	for(i=0;i<threads;i++){ //Waiting for Threads
		pthread_join(pthreads[i],&status);
		option_price_0 += temp_data[i].thread_result[0];
		option_price_0_confidence_interval += temp_data[i].thread_result_sqrd[0]; //accumulating variances for calculating the confidence interval
		}

	//**Calculating Final Option Value and Return**
	option_price_0 = option_price_0/paths;//Calculate final value and return value as well as timing
	option_price_0 = option_price_0*discount_0_0;
	option_price_0_confidence_interval = option_price_0_confidence_interval*pow(discount_0_0,2);

	option_price_0_confidence_interval = 1.96*pow((option_price_0_confidence_interval-paths*pow(option_price_0,2)),0.5)/paths; //Calculate final confidence interval
	printf("\%f\n"
	,option_price_0);
	printf("\%f\n"
	,option_price_0_confidence_interval);


    return 0;
}


void vivado_activity_thread_hw(standard_underlying_attributes *kernel_u_a_0,standard_derivative_attributes *kernel_o_a_0,rng_state_t *seed_0,unsigned int thread_result_addr)
{
	//volatile unsigned long * vivado_core_vbase = vivado_core_userspace();
	XVivado_activity_thread  device_info;
	device_info.Core_io_BaseAddress = VIVADO_CORE_ADDR;
	device_info.IsReady = 1;

    //------------------------------------AXI Master Setup------------------------------------------
    XVivado_activity_thread_SetThread_result_0(&device_info, thread_result_addr); //Okay the base address is now set for the thread result into the AXI master

	//------------------------------------INPUT SECTION---------------------------------------------
	//PASSING kernel_u_a_0 to the device
	XVivado_activity_thread_SetKernel_u_a_0_rfir(&device_info, *(int*)&kernel_u_a_0->rfir);
	XVivado_activity_thread_SetKernel_u_a_0_current_price(&device_info, *(int*)&kernel_u_a_0->current_price);
	XVivado_activity_thread_SetKernel_u_a_0_volatility(&device_info, *(int*)&kernel_u_a_0->volatility);
	XVivado_activity_thread_SetKernel_u_a_0_initial_volatility(&device_info, *(int*)&kernel_u_a_0->initial_volatility);
	XVivado_activity_thread_SetKernel_u_a_0_volatility_volatility(&device_info, *(int*)&kernel_u_a_0->volatility_volatility);
	XVivado_activity_thread_SetKernel_u_a_0_rho(&device_info, *(int*)&kernel_u_a_0->rho);
	XVivado_activity_thread_SetKernel_u_a_0_kappa(&device_info, *(int*)&kernel_u_a_0->kappa);
	XVivado_activity_thread_SetKernel_u_a_0_theta(&device_info, *(int*)&kernel_u_a_0->theta);
	XVivado_activity_thread_SetKernel_u_a_0_correlation_matrix_0_0(&device_info, *(int*)&kernel_u_a_0->correlation_matrix_0_0);
	XVivado_activity_thread_SetKernel_u_a_0_correlation_matrix_0_1(&device_info, *(int*)&kernel_u_a_0->correlation_matrix_0_1);
	XVivado_activity_thread_SetKernel_u_a_0_correlation_matrix_1_0(&device_info, *(int*)&kernel_u_a_0->correlation_matrix_1_0);
	XVivado_activity_thread_SetKernel_u_a_0_correlation_matrix_1_1(&device_info, *(int*)&kernel_u_a_0->correlation_matrix_1_1);

	//PASSING kernel_o_a_0 to the device
	XVivado_activity_thread_SetKernel_o_a_0_second_barrier(&device_info, *(int*)&kernel_o_a_0->second_barrier);
	XVivado_activity_thread_SetKernel_o_a_0_barrier(&device_info, *(int*)&kernel_o_a_0->barrier);
	XVivado_activity_thread_SetKernel_o_a_0_out(&device_info, *(int*)&kernel_o_a_0->out);
	XVivado_activity_thread_SetKernel_o_a_0_down(&device_info, *(int*)&kernel_o_a_0->down);
	XVivado_activity_thread_SetKernel_o_a_0_strike_price(&device_info, *(int*)&kernel_o_a_0->strike_price);
	XVivado_activity_thread_SetKernel_o_a_0_time_period(&device_info, *(int*)&kernel_o_a_0->time_period);
	XVivado_activity_thread_SetKernel_o_a_0_call(&device_info, *(int*)&kernel_o_a_0->call);
	XVivado_activity_thread_SetKernel_o_a_0_points(&device_info, *(int*)&kernel_o_a_0->points);

	//PASSING seed_0 to the device
	XVivado_activity_thread_SetSeed_0_s1(&device_info, *(int*)&seed_0->s1);
	XVivado_activity_thread_SetSeed_0_s2(&device_info, *(int*)&seed_0->s2);
	XVivado_activity_thread_SetSeed_0_s3(&device_info, *(int*)&seed_0->s3);
	XVivado_activity_thread_SetSeed_0_offset(&device_info, *(int*)&seed_0->offset);

	XVivado_activity_thread_Start(&device_info); //Kick the device into starting
	while(XVivado_activity_thread_IsDone(&device_info) != 1) { } //Waiting for the operation to complete

	//u32 temp_thread_result_0 = XVivado_activity_thread_GetThread_result_0(&device_info);
	//u32 temp_thread_result_sqrd_0 = XVivado_activity_thread_GetThread_result_sqrd_0(&device_info);

	//Converting the results to float and outputting
	//*thread_result_0 = *(float*)&temp_thread_result_0;
	//*thread_result_sqrd_0 = *(float*)&temp_thread_result_sqrd_0;
}
