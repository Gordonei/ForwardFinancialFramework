//mc_solver_maxeler_fpga_un_1_op_1_cslow_True_pipe_1_insts_1_delay_13.c Generated by Monte Carlo Maxeler Solver

//*Libraries
#define __STDC_FORMAT_MACROS
#include "math.h"
#include "pthread.h"
#include "stdint.h"
#include "stdlib.h"
#include "stdio.h"
#include "time.h"
#include "sys/resource.h"
#include "unistd.h"
#include "string.h"
#include "Maxfiles.h"
#include "MaxSLiCInterface.h"
#include "gauss.h"

//*Intermediate and Communication Variables*
FP_t discount_0_0;
FP_t option_price_0;
FP_t option_price_0_confidence_interval;
static FP_t underlying_0_rfir;
static FP_t underlying_0_current_price;
static FP_t option_0_time_period;
static FP_t option_0_call;
static FP_t option_0_strike_price;
static int default_points;
static int delay;
static int instance_paths;
static int instances;
static int path_points;
static int paths;
static int rng_seed;
static int threads;
int thread_paths,i,j;
struct thread_data{
	int thread_paths;
	unsigned int thread_rng_seed;
	long double *thread_result;
	long double *thread_result_sqrd;
	};

//*Performance Monitoring Variables*
FP_t setup_time,activity_time;
struct timespec start, setup_end, end;
int ret,ret_2;

//*MC Maxeler Activity Thread Function*
void * maxeler_montecarlo_activity_thread(void* thread_arg){
	struct thread_data* temp_data;
	temp_data = (struct thread_data*) thread_arg;

	//**Creating kernel IO variables**
	uint32_t *seeds_in;
	float *values_out;
	seeds_in = malloc(8*instance_paths*sizeof(uint32_t));
	values_out = malloc(4*instance_paths*sizeof(float));
	long double temp_total_0=0;
	long double temp_value_sqrd_0=0;

	//**Generating initial random seed**
	uint32_t initial_seed = temp_data->thread_rng_seed;
	rng_state_t temp_state_x,temp_state_y;
	int loops = ceil(((float)paths)/instance_paths/instances);
	if(loops==0) loops = 1;
	unsigned int paths_count = 0;
	for (i=0;i < loops;++i){

		//**Populating Seed Array(s)**
		for (j=0;j<(instance_paths);++j){
			ctrng_seed(10,initial_seed,&temp_state_x);
			seeds_in[j*8] = temp_state_x.s1;
			seeds_in[j*8+1] = temp_state_x.s2;
			seeds_in[j*8+2] = temp_state_x.s3;
			seeds_in[j*8+3] = temp_state_x.offset;
			initial_seed = __random32(&temp_state_x);
			ctrng_seed(10,initial_seed,&temp_state_y);
			seeds_in[j*8+4] = temp_state_y.s1;
			seeds_in[j*8+5] = temp_state_y.s2;
			seeds_in[j*8+6] = temp_state_y.s3;
			seeds_in[j*8+7] = temp_state_y.offset;
			initial_seed = __random32(&temp_state_y);
			}

		//**Running on the FPGA**
		mc_solver_maxeler_fpga_un_1_op_1_cslow_True_pipe_1_insts_1_delay_13(
		underlying_0_rfir,
		underlying_0_current_price,

		//****Derivative Attributes****
		option_0_time_period,
		option_0_call,
		option_0_strike_price,
		seeds_in,
		values_out);

		//**Post-Kernel Aggregation**
		for (j=0;(j<(instance_paths*4))&&(paths_count<paths);j = j + 4){
			temp_total_0 += values_out[j+2*0];
			temp_value_sqrd_0 += values_out[j+2*0+1];
			paths_count += 1;
			}
		}

	//**Returning Result**
	temp_data->thread_result[0] = temp_total_0;
	temp_data->thread_result_sqrd[0] = temp_value_sqrd_0;
	}

//*Main Function*
int main(int argc,char* argv[]){

	//**Starting Timers**
	clock_gettime(CLOCK_MONOTONIC,&start);

	//**Unpacking Command Line Variables**

	//***Solver Metadata***
	default_points = atoi(argv[1]);
	delay = atoi(argv[2]);
	instance_paths = atoi(argv[3]);
	instances = atoi(argv[4]);
	path_points = atoi(argv[5]);
	paths = atoi(argv[6]);
	rng_seed = atoi(argv[7]);
	threads = atoi(argv[8]);

	//***Underlying Attributes***
	underlying_0_rfir = strtof(argv[9],NULL);
	underlying_0_current_price = strtof(argv[10],NULL);

	//***Derivative Attributes***
	option_0_time_period = strtof(argv[11],NULL);
	option_0_call = strtof(argv[12],NULL);
	option_0_strike_price = strtof(argv[13],NULL);

	//**Calculating Discount Factor**
	discount_0_0 = exp(-underlying_0_rfir*option_0_time_period);

	//**Creating Thread Variables**
	thread_paths = paths/threads;
	pthread_t pthreads[threads];
	struct thread_data temp_data[threads];
	for(i=0;i<threads;i++){
		temp_data[i].thread_result=(long double*)malloc(1*sizeof(long double));
		temp_data[i].thread_result_sqrd=(long double*)malloc(1*sizeof(long double));
		}
	pthread_attr_t attr;
	pthread_attr_init(&attr);
	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);

	//**Packing up data and passing to threads**
	int i;
	for(i=0;i<threads;i++){ //Generating Threads
		temp_data[i].thread_paths = thread_paths;
		temp_data[i].thread_rng_seed = rng_seed + i*thread_paths*1;
		if(i==(threads-1)){ //If final thread, allocating any remaining paths to it (i.e. PATHS%THREADS!=0)
			temp_data[i].thread_paths += paths%threads;
			}
		pthread_create(&pthreads[i],&attr,maxeler_montecarlo_activity_thread,&temp_data[i]);
		}
	clock_gettime(CLOCK_MONOTONIC,&setup_end);

	//**Waiting for threads to join**
	void *status;
	option_price_0 = 0;
	option_price_0_confidence_interval = 0;
	for(i=0;i<threads;i++){ //Waiting for Threads
		pthread_join(pthreads[i],&status);
		option_price_0 += temp_data[i].thread_result[0];
		option_price_0_confidence_interval += temp_data[i].thread_result_sqrd[0]; //accumulating variances for calculating the confidence interval
		}

	//**Calculating Final Option Value and Return**
	option_price_0 = option_price_0/paths;//Calculate final value and return value as well as timing
	option_price_0 = option_price_0*discount_0_0;
	option_price_0_confidence_interval = option_price_0_confidence_interval*pow(discount_0_0,2);

	option_price_0_confidence_interval = 1.96*pow((option_price_0_confidence_interval-paths*pow(option_price_0,2)),0.5)/paths; //Calculate final confidence interval
	printf("\%f\n"
	,option_price_0);
	printf("\%f\n"
	,option_price_0_confidence_interval);

	//**Performance Monitoring Calculation and Return**
	clock_gettime(CLOCK_MONOTONIC,&end);
	setup_time = 1000000*(setup_end.tv_sec-start.tv_sec)+(setup_end.tv_nsec-start.tv_nsec)/1000;
	activity_time = 1000000*(end.tv_sec-setup_end.tv_sec)+(end.tv_nsec-setup_end.tv_nsec)/1000;
	printf("\%f\n",setup_time);
	printf("\%f\n",activity_time);
	}
