'''
Created on 30 October 2012

'''
import os,time,subprocess,sys,time,math,multiprocessing #,numpy
from ForwardFinancialFramework.Platforms.MulticoreCPU import MulticoreCPU_MonteCarlo
from ForwardFinancialFramework.Underlyings import Underlying
from ForwardFinancialFramework.Derivatives import Option
from ForwardFinancialFramework.Solvers.MonteCarlo import MonteCarlo
import MaxelerFPGA

class MaxelerFPGA_MonteCarlo(MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo):
	"""Maxeler Monte Carlo solver class
	
	This class provides the generation and compilation behaviour for the Maxeler FPGA platform.
	"""
	
	c_slow = False
	##Integer delay value to be used if the c-slowing optimisation is not used
	delay = 10
	pipelining = 1
	instances=1
	
	def __init__(self,derivative,paths,platform,points=4096,reduce_underlyings=True,instance_paths=None,c_slow=None,pipelining=None,instances=None):
		"""Constructor

		Parameters
			derivative, paths, platform, reduce_underlyings - same as for MulticoreCPU_MonteCarlo class
			instance_paths - (int) number of paths to perform per call to the Maxeler DFE
			c_slow - (bool) option to use c-slowing optimisation
			pipelining - (int) amount of loop unrolling to perform
			instances - (int) number of parallel instances to use
		"""
		
		##Option for whether c-slowing optimisation should be used
		self.c_slow = c_slow
		##Integer degree of loop unrolling to be performed
		self.pipelining = pipelining
		##Number of parallel task instances to be performed
		self.instances = instances
		
		MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.__init__(self,derivative,paths,platform,reduce_underlyings,floating_point_format="float")
		self.delay = self.get_delay()

		self.solver_metadata["instances"] = self.instances
		if (not(instance_paths) and self.c_slow): self.solver_metadata["instance_paths"] = 1000*((self.delay-self.delay%1000)/1000+1) #rounding up the number of paths to the nearest 1000
		elif(not(instance_paths)): self.solver_metadata["instance_paths"] = 1000 #this gives us plenty of time to do the necessary accumulation on the CPU
		else: self.solver_metadata["instance_paths"] = instance_paths #using the specified value
		self.solver_metadata["path_points"] = points
		self.solver_metadata["delay"] = self.delay
			  	
		self.utility_libraries += ["Maxfiles.h","MaxSLiCInterface.h","gauss.h"]    

		self.activity_thread_name = "maxeler_montecarlo_activity_thread"
		#self.floating_point_format = "float"
		
	def set_default_parameters(self):
		"""Helper method for setting the default FPGA parameters to use
		"""
		if not(self.pipelining): self.pipelining = 1
		self.delay = self.get_delay()
		if not(self.instances):
			heston_count = 0
			black_scholes_count = 0
			underlying_count = 0
	
			for d in self.derivative:
				for u in d.underlying:
	 				if("heston" in u.name): heston_count += 1
	 				elif("black_scholes" in u.name): black_scholes_count += 1
	 				else: underlying_count += 1

			self.instances = max(1,int(self.platform.device_resources/(heston_count*2.2 + black_scholes_count + underlying_count)))
			
		if not(self.c_slow): self.c_slow = True  

	def generate_name(self):
		"""Overriding helper method to include board parameters
		"""
		self.set_default_parameters()
		MonteCarlo.MonteCarlo.generate_name(self) 
		self.output_file_name += "_cslow_%s_pipe_%d_insts_%d_delay_%d_board_%s"%(str(self.c_slow),self.pipelining,self.instances,self.delay,self.platform.board)
	
	def generate_identifier(self): return ["//%s.c Generated by Monte Carlo Maxeler Solver"%self.output_file_name]
	
	def generate(self,override=True,verbose=False,debug=False):
		"""Overriding generate method. In addition to host code, the code for Maxeler DFE and its manager class are generated.

		Parameters
			override, verbose, debug - same as for MulticoreCPU_MonteCarlo class
		"""
		#Generate C Host Code largely using Multicore infrastructure
		MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate(self,"_Host_Code.c",override,verbose=verbose,debug=debug)
		
		#Generate Maxeler Kernel Code
		kernel_code_string = self.generate_kernel()
		self.generate_source(kernel_code_string,"_Kernel.maxj")
		if(debug): print "Generated %s/%s_Kernel.maxj"%(self.platform.absolute_platform_directory(),self.output_file_name)    

		#Generate Maxeler Manager Code
		manager_code_string = self.generate_manager()
		self.generate_source(manager_code_string,"_Manager.maxj")
		if(debug): print "Generated %s/%s_Manager.maxj"%(self.platform.absolute_platform_directory(),self.output_file_name)

	
	
	def generate_activity_thread(self):
		"""Overriding the generate activity thread method so that it sets up and communicates with the Maxeler DFE
		"""
		output_list = []

		output_list.append("//*MC Maxeler Activity Thread Function*")
		output_list.append("void * %s(void* thread_arg){"%self.activity_thread_name)
		output_list.append("struct thread_data* temp_data;")

		output_list.append("seeds_in = malloc(%d*instance_paths*sizeof(uint32_t));"%(int(seeds_in*4)))
		output_list.append("values_out = malloc(%d*instance_paths*sizeof(float));"%(int(values_out*4)))
		
		for d in range(len(self.derivative)): 
			output_list.append("long double temp_total_%d=0;"%d)
			output_list.append("long double temp_value_sqrd_%d=0;"%d)
		
		output_list.append("//**Generating initial random seed**")
		output_list.append("uint32_t initial_seed = temp_data->thread_rng_seed;") #%%((uint32_t)pow(2,31)-%d);"%(seeds_in*self.iterations)) #Start the seeds off at some random point
		output_list.append("rng_state_t temp_state_x,temp_state_y;")
		
		output_list.append("int loops = ceil(((float)paths)/instance_paths/instances);");
		output_list.append("if(loops==0) loops = 1;")
		output_list.append("unsigned int paths_count = 0;")
		output_list.append("for (i=0;i < loops;++i){")
		
		output_list.append("//**Populating Seed Array(s)**")
		for index,u in enumerate(self.underlying):
			output_list.append("for (j=0;j<(instance_paths);++j){")
			output_list.append("ctrng_seed(10,initial_seed,&temp_state_x);")
			output_list.append("seeds_in[j+%d*8*instance_paths] = temp_state_x.s1;"%index)
			output_list.append("seeds_in[j+1*instance_paths+%d*8*instance_paths] = temp_state_x.s2;"%index)
			output_list.append("seeds_in[j+2*instance_paths+%d*8*instance_paths] = temp_state_x.s3;"%index)
			output_list.append("seeds_in[j+3*instance_paths+%d*8*instance_paths] = temp_state_x.offset;"%index)
			
			#output_list.append("initial_seed = (uint32_t)(drand48()*pow(2,32)-16);");
			output_list.append("initial_seed = __random32(&temp_state_x);");
			output_list.append("ctrng_seed(10,initial_seed,&temp_state_y);")
			output_list.append("seeds_in[j+4*instance_paths+%d*8*instance_paths] = temp_state_y.s1;"%index)
			output_list.append("seeds_in[j+5*instance_paths+%d*8*instance_paths] = temp_state_y.s2;"%index)
			output_list.append("seeds_in[j+6*instance_paths+%d*8*instance_paths] = temp_state_y.s3;"%index)
			output_list.append("seeds_in[j+7*instance_paths+%d*8*instance_paths] = temp_state_y.offset;"%index)
			output_list.append("initial_seed = __random32(&temp_state_y);");
			output_list.append("}")
	
		
		output_list.append("//**Running on the FPGA**")
		output_list.append("%s("%self.output_file_name)
		output_list.append("//****Scaler Attributes****") 
		temp_list = []
		for index,u_a in enumerate(sorted(self.underlying_attributes)):
			  for a in u_a:
			      attribute = "%s_%d_%s," % (self.underlying[index].name,index,a)
			      temp_list += [attribute]
		
		for index,o_a in enumerate(sorted(self.derivative_attributes)):
			  for a in o_a:
			      attribute = "%s_%d_%s," % (self.derivative[index].name,index,a)
			      temp_list += [attribute]

		output_list.append("//****Inputs and Output****") 
		for index in range(len(self.underlying)*8): output_list.append("&(seeds_in[%d*instance_paths]),"%(index))
		for index in range(len(self.derivative)*2): output_list.append("&(values_out[%d*instance_paths]),"%(index))
		output_list[-1] = "%s"%output_list[-1][:-1] #removing the final comma
		output_list.append(");")
		
		output_list.append("//**Post-Kernel Aggregation**")
		output_list.append("for (j=0;(j<(instance_paths)&&(paths_count<paths));++j){")
		for index,d in enumerate(self.derivative):
			output_list.append("temp_total_%d += values_out[j+%d*instance_paths*2];"%(index,index))
			output_list.append("temp_value_sqrd_%d += values_out[j+instance_paths*1+%d*instance_paths*2];"%(index,index))
			output_list.append("paths_count += %d;"%self.instances)
		output_list.append("}")
			
		output_list.append("}")

		output_list.append("//**Returning Result**")
		for d in self.derivative: 
			output_list.append("temp_data->thread_result[%d] = temp_total_%d;"%(self.derivative.index(d),self.derivative.index(d)))
			output_list.append("temp_data->thread_result_sqrd[%d] = temp_value_sqrd_%d;"%(self.derivative.index(d),self.derivative.index(d)))
		output_list.append("}")
		
		return output_list
	
	def generate_libraries(self):
		"""Overriding the libraries generation
		"""
		output_list = ["//*Libraries"]
		output_list.append("#define __STDC_FORMAT_MACROS")
		for u in self.utility_libraries: output_list.append("#include \"%s\""%u)
		
		return output_list
 
	def generate_kernel(self,overide=True):
		"""Helper method for generating the kernel.

		Parameters
			overide - (bool) Force the code to be generated.
		"""
		output_list = []
			
		#Maxeler Library Imports
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEArray;")
		
		#Class Declaration
		output_list.append("public class %s_Kernel extends MC_Solver_Maxeler_Base_Kernel {"%self.output_file_name)
		
		seeds_in = math.ceil(float(len(self.underlying))/2)*4 #Making sure seeds_in is in increments of 128 bits
		values_out = math.ceil(float(len(self.derivative))/2)*4 #Making sure values_out are in increments of 128 bits
		
		#Class Constructor Declaration and call to parent class constructor
		output_list.append("//*Kernel Class*\n")
		output_list.append("public %s_Kernel(KernelParameters parameters,int instance_paths,int path_points,int instances,int delay){"%self.output_file_name)
		output_list.append("super(parameters,instance_paths,path_points,instances,delay);")
		
		#Counters
		output_list.append("//**Counters**\n")
		output_list.append("CounterChain chain = control.count.makeCounterChain();")
		
		if(self.c_slow):
			output_list.append("DFEVar pp = chain.addCounter(this.path_points+1,%d).cast(dfeUInt(32));"%(self.pipelining)) #Path Points is the outer loop so as to implement a C-Slow architecture
			output_list.append("DFEVar p = chain.addCounter(this.instance_paths,1).cast(dfeUInt(32));")
			output_list.append("DFEVar d = p;") #Just make the delay counter equal to the path counter - it functions as the same thing
		else:
			output_list.append("DFEVar p = chain.addCounter(this.instance_paths,1).cast(dfeUInt(32));")
			output_list.append("DFEVar pp = chain.addCounter(this.path_points+1,%d).cast(dfeUInt(32));"%(self.pipelining)) #Path Points is the outer loop so as to implement a C-Slow architecture
			output_list.append("DFEVar d = chain.addCounter(this.delay,1);")
		
		#Scaler Inputs
		output_list.append("//**Scaler Inputs**\n")
		temp_list = []
		for index,u_a in enumerate(sorted(self.underlying_attributes)):
			  for a in u_a:
			      temp_attribute_name = "%s_%d_%s" % (self.underlying[index].name,index,a)
			      temp_list += ["DFEVar %s = (io.scalarInput(\"%s\", inputFloatType));"%(temp_attribute_name,temp_attribute_name)]
			  index += 1
		
		#output_list.append("//***Derivative Attributes***")
		for index,o_a in enumerate(sorted(self.derivative_attributes)):
			for a in o_a:
				temp_attribute_name = "%s_%d_%s" % (self.derivative[index].name,index,a)
				temp_list += ["DFEVar %s = (io.scalarInput(\"%s\", inputFloatType));"%(temp_attribute_name,temp_attribute_name)]
		
		output_list += sorted(temp_list)        

		output_list.append("//**Random Seed Input**\n")
		
		input_condition = "pp.eq(0)&d.eq(0)"
		if(self.c_slow): input_condition = "pp.eq(0)"

		for index in range(len(self.underlying)*8):
			output_list.append("DFEVar seeds_in_%d = io.input(\"seeds_in_%d\",Kernel.dfeUInt(32),%s);"%(index,index,input_condition))
 
		for index,d in enumerate(self.derivative): 
			output_list.append("DFEVar accumulate_%d = this.constant.var(this.inputDoubleType,0.0);"%index)
			output_list.append("DFEVar accumulate_sqrd_%d = this.constant.var(this.inputDoubleType,0.0);"%index)
	
			output_list.append("DFEVar delta_time_%d = %s_%d_time_period/this.path_points;"%(index,d.name,index))
	
		output_list.append("//**Parallelism Loop**")
		output_list.append("for (int i=0;i<this.instances;i++){")
		
		output_list.append("//***Underlying and Derivative Declaration(s)***")
		for index,d in enumerate(self.derivative):
			#Creating the parameter object
			temp_string = "%s_parameters %s_%d_parameters = new %s_parameters(this" % (d.name,d.name,index,d.name)
			for d_a in self.derivative_attributes[index][:-1]: temp_string = ("%s,%s_%d_%s"%(temp_string,d.name,index,d_a))
			temp_string = "%s,%s_%d_%s);"%(temp_string,d.name,index,self.derivative_attributes[index][-1])
			
			output_list.append(temp_string)
			
		for index,u in enumerate(self.underlying):
			#Creating the parameter object
			temp_string = "%s_parameters %s_%d_parameters = new %s_parameters(this" % (u.name,u.name,index,u.name)
			for u_a in self.underlying_attributes[index][:-1]: temp_string = ("%s,%s_%d_%s"%(temp_string,u.name,index,u_a))
			temp_string = "%s,%s_%d_%s);"%(temp_string,u.name,index,self.underlying_attributes[index][-1])
			
			output_list.append(temp_string)
		
		temp_path_call_underlying = []
		temp_path_call_derivative = []
		for pipe in range(self.pipelining):
			output_list.append("//***Pipeline Stage %d***"%pipe)
			rng_index = 0
			for index,u in enumerate(self.underlying):
				#If there is a random number generator, this needs to be created and linked to the input seeds
				if("heston" in u.name or "black_scholes" in u.name):
	 				cycle_length = "this.instance_paths*(this.path_points+1)*this.delay"
	 				if(self.c_slow): cycle_length = "this.instance_paths*(this.path_points+1)"
	 				output_list.append("CombinedTauswortheRNG %s_%d_x_%d = new CombinedTauswortheRNG(this,%s,seeds_in_%d,seeds_in_%d+i,seeds_in_%d+i,seeds_in_%d);"%(u.name,index,pipe,cycle_length,index*8,index*8+1,index*8+2,index*8+3))
	 				output_list.append("CombinedTauswortheRNG %s_%d_y_%d = new CombinedTauswortheRNG(this,%s,seeds_in_%d,seeds_in_%d+i,seeds_in_%d+i,seeds_in_%d);"%(u.name,index,pipe,cycle_length,index*8+4,index*8+5,index*8+6,index*8+7))
	 
	 				output_list.append("%s %s_%d_%d = new %s(this,%s_%d_x_%d,%s_%d_y_%d,pp,p,d,%s_%d_parameters);"%(u.name,u.name,index,pipe,u.name,u.name,index,pipe,u.name,index,pipe,u.name,index))
	 
	
				else: output_list.append("%s %s_%d_%d = new %s(this,pp,p,d,%s_%d_parameters);"%(u.name,u.name,index,pipe,u.name,u.name,index))
	
			output_list.append("%s_%d_%d.path_init();"%(u.name,index,pipe))
	
			for index,d in enumerate(self.derivative):
				output_list.append("%s %s_%d_%d = new %s(this,pp,p,d,this.constant.var(true),%s_%d_parameters);"%(d.name,d.name,index,pipe,d.name,d.name,index))
				output_list.append("%s_%d_%d.path_init();"%(d.name,index,pipe)) #path initialisation
			
			output_list.append("//***Path Initialisation and Path Calls***")
			
			for d_index,d in enumerate(self.derivative):
				for u_index,u in enumerate(d.underlying):
	 				if("%s_%d_%d"%(u.name,u_index,pipe) not in temp_path_call_underlying): #checking to see if this path has not been called already
		 				output_list.append("%s_%d_%d.path(delta_time_%d);"%(u.name,u_index,pipe,d_index)) #Calling the path function
						temp_path_call_underlying.append("%s_%d_%d"%(u.name,u_index,pipe))
			
		 			output_list.append("DFEVar temp_price_%d_%d = (%s_%d_%d.parameters.current_price*KernelMath.exp(%s_%d_%d.gamma));"%(u_index,pipe,u.name,u_index,pipe,u.name,u_index,pipe))
	 				output_list.append("%s_%d_%d.path(temp_price_%d_%d,%s_%d_%d.time);"%(d.name,d_index,pipe,u_index,pipe,u.name,u_index,pipe))
	 
				temp_path_call_derivative.append("%s_%d_%d"%(d.name,d_index,pipe))
	
			
			output_list.append("//***Path Connect Calls***")
			for index,tpc in enumerate(temp_path_call_underlying): #this is fairly dodgy - TODO improve
				if(int(tpc[-1])>0): #connect each point in the pipeline to the value that proceeded it
					output_list.append("%s.connect_path(true,%s%d.new_gamma,%s%d.new_time);"%(tpc,tpc[:-1],int(tpc[-1])-1,tpc[:-1],int(tpc[-1])-1))
			
					if("heston" in tpc): output_list[-1] = "%s,%s%d.new_volatility);"%(output_list[-1][:-2],tpc[:-1],int(tpc[-1])-1)
				else: #loop back to the end for the first value in the pipeline
					output_list.append("%s.connect_path(false,%s%d.new_gamma,%s%d.new_time);"%(tpc,tpc[:-1],self.pipelining-1,tpc[:-1],self.pipelining-1))
					if("heston" in tpc): output_list[-1] = "%s,%s%d.new_volatility);"%(output_list[-1][:-2],tpc[:-1],self.pipelining-1)	

			for index,tpc in enumerate(temp_path_call_derivative):
				if(int(tpc[-1])>0): #connect each point in the pipeline to the value that proceeded it
					output_list.append("%s.connect_path(true);"%tpc)
					
					if("asian" in tpc): output_list[-1] = "%s,%s%d.new_average);"%(output_list[-1][:-2],tpc[:-1],int(tpc[-1])-1)
					if("barrier" in tpc): output_list[-1] = "%s,%s%d.new_barrier_event);"%(output_list[-1][:-2],tpc[:-1],int(tpc[-1])-1)
				else: #loop back to the end for the first value in the pipeline
					output_list.append("%s.connect_path(false);"%tpc)
					if("asian" in tpc): output_list[-1] = "%s,%s%d.new_average);"%(output_list[-1][:-2],tpc[:-1],self.pipelining-1)
					if("barrier" in tpc): output_list[-1] = "%s,%s%d.new_barrier_event);"%(output_list[-1][:-2],tpc[:-1],self.pipelining-1)
		 
	
		output_list.append("//***Path Payoff and Accumulate Calls***") 
		for index,d in enumerate(self.derivative):
			#We're only interested in the payoff for the last path step 
			output_list.append("DFEVar payoff_%d = %s_%d_%d.payoff(temp_price_%d_%d);"%(d_index,d.name,d_index,self.pipelining-1,self.underlying.index(d.underlying[0]),self.pipelining-1))
			output_list.append("accumulate_%d += payoff_%d;"%(d_index,d_index))
			output_list.append("accumulate_sqrd_%d += payoff_%d*payoff_%d;"%(d_index,d_index,d_index))
		
		output_list.append("}") #End of parallelism loop
		
		output_list.append("//**Copying Outputs to Output array and outputing it**")	
		output_condition = "pp.eq(this.path_points-1)&d.eq(0)"
		if(self.c_slow): output_condition = "pp.eq(this.path_points-1)"

		for index,d in enumerate(self.derivative):
			output_list.append("io.output(\"values_out_%d\",(accumulate_%d).cast(this.inputFloatType),this.inputFloatType,%s);"%(index*2,index,output_condition))
			output_list.append("io.output(\"values_out_%d\",(accumulate_sqrd_%d).cast(this.inputFloatType),this.inputFloatType,%s);"%(index*2+1,index,output_condition))
			 
		output_list.append("}")
		output_list.append("}")
		
		return output_list
		
	def generate_manager(self):
		"""Helper method for generating Maxeler hardware manager, which specifies communication and various build properities.
		"""
		output_list = []
		#Maxeler Library imports
		output_list.append("import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;")
		output_list.append("import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;")
		output_list.append("import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;")
		output_list.append("import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;")
		output_list.append("import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;")
		output_list.append("import com.maxeler.maxcompiler.v2.build.EngineParameters;")
		output_list.append("import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;")  
		output_list.append("import com.maxeler.maxcompiler.v2.managers.custom.ManagerClock;")    
		output_list.append("import com.maxeler.maxcompiler.v2.managers.BuildConfig;")

		#Class declaration
		output_list.append("public class %s_Manager extends CustomManager{"%self.output_file_name)
		
		#Kernel Variable Setting
		output_list.append("private static final int instance_paths = %d;"%self.solver_metadata["instance_paths"])
		output_list.append("private static final int path_points = %d;"%self.solver_metadata["path_points"])
		output_list.append("private static final int instances = %d;"%self.solver_metadata["instances"])
		
		if(self.c_slow): output_list.append("private static int delay = instance_paths;")
		else: output_list.append("private static int delay = %d;"%self.delay)
		
		#Manager Declaration
		output_list.append("%s_Manager(EngineParameters ep){"%self.output_file_name)
		output_list.append("super(ep);")    

		#Optimisation Options
		output_list.append("KernelConfiguration currKConf = getCurrentKernelConfig();")
 

		#Kernel Declaration and parameter setting
		output_list.append("KernelBlock k = addKernel(new %s_Kernel(makeKernelParameters(\"%s_Kernel\"),instance_paths,path_points,instances,delay));"%(self.output_file_name,self.output_file_name))
		#Setting the clock
		output_list.append("ManagerClock clock = generateStreamClock(\"%s_clock\",%d);"%(self.output_file_name,self.platform.clock_rate))
		output_list.append("k.setClock(clock);")    
		
		for index,u in enumerate(self.underlying): 
			for k in range(8): output_list.append("k.getInput(\"seeds_in_%d\") <== addStreamFromCPU(\"seeds_in_%d\");"%(index*8+k,index*8+k))   
		
		for index,d in enumerate(self.derivative): 
			output_list.append("addStreamToCPU(\"values_out_%d\") <== k.getOutput(\"values_out_%d\");"%(index*2,index*2))
			output_list.append("addStreamToCPU(\"values_out_%d\") <== k.getOutput(\"values_out_%d\");"%(index*2+1,index*2+1))
		
		#Build Configuration
		output_list.append("BuildConfig c = new BuildConfig(BuildConfig.Level.FULL_BUILD);")
		output_list.append("c.setBuildEffort(BuildConfig.Effort.VERY_HIGH);")  #LOW,MEDIUM,HIGH,VERY_HIGH
		output_list.append("c.setEnableTimingAnalysis(true);")
		output_list.append("c.setMPPRCostTableSearchRange(1,100);")
		threads = int(math.ceil(multiprocessing.cpu_count()))
		if(threads>4): threads = 4
		output_list.append("c.setMPPRParallelism(%d);"%threads) #This has to be done carefully, as it takes a *lot* of RAM
		output_list.append("setBuildConfig(c);")
		output_list.append("}")#Closing off Manager decleration

		#Interface Decleration
		output_list.append("private static EngineInterface interfaceDefault(){") 
		output_list.append("EngineInterface engine_interface = new EngineInterface();")
		
		output_list.append("CPUTypes inType = CPUTypes.UINT32;")
		output_list.append("int inSize = inType.sizeInBytes();")
		output_list.append("CPUTypes outType = CPUTypes.FLOAT;")
		output_list.append("int outSize = outType.sizeInBytes();") 

		if(self.c_slow):
			output_list.append("engine_interface.setTicks(\"%s_Kernel\",instance_paths*(path_points+1));"%self.output_file_name)
		else:
			output_list.append("engine_interface.setTicks(\"%s_Kernel\",instance_paths*(path_points/%d+1)*delay);"%self.output_file_name)
		
		for index,u in enumerate(self.underlying): 
			for k in range(8): output_list.append("engine_interface.setStream(\"seeds_in_%d\", inType, inSize*instance_paths);"%(index*8+k))
		for index,d in enumerate(self.derivative): 
			output_list.append("engine_interface.setStream(\"values_out_%d\", outType, outSize*instance_paths);"%(index*2))
			output_list.append("engine_interface.setStream(\"values_out_%d\", outType, outSize*instance_paths);"%(index*2+1))
		output_list.append("return engine_interface;")
		
		output_list.append("}")

		#main
		output_list.append("public static void main(String[] args){")
		output_list.append("%s_Manager manager = new %s_Manager(new EngineParameters(args));"%(self.output_file_name,self.output_file_name))
		output_list.append("manager.createSLiCinterface(interfaceDefault());")
		output_list.append("manager.build();")
		output_list.append("}")
		

		output_list.append("}")#Closing off Class decleration
		
		return output_list
	 
	def compile(self,override=True,cleanup=True,debug=True):
		"""Compiler method override for Maxeler solvers.

		Makes use of GNU make infrastructure underneath.

		Parameters
			override, cleanup, debug - same as in other solver classes
		"""
		if(override):
			#Hardware Build Process
			compile_cmd = ["make","-C","%s/../build"%self.platform.absolute_platform_directory(),"build","APP=%s"%self.output_file_name]
			if(self.platform.board!="max3"): compile_cmd += ["MAX3=false"]  
		
			compile_string = ""
			for c_c in compile_cmd: compile_string += " %s"%c_c
			if(debug): print compile_string
			
			hw_result = subprocess.check_output(compile_cmd)
			
			return hw_result
			 
	
		
	def dummy_run(self):
			"""Helper method for wiping the configuration of the current Maxeler board.
			"""
			rfir = 0.1
			current_price = 100
			time_period = 1.0
			call = 1.0
			strike_price = 100
			paths = 1000
			
			underlying = [Underlying.Underlying(rfir,current_price)]
			option = [Option.Option(underlying,time_period,call,strike_price)]
			
			delay = self.solver_metadata["delay"]
			mc_solver = MaxelerFPGA_MonteCarlo(option,paths,self.platform,instances=1) #because we can do recursive calls like this
			
			mc_solver.execute()
			self.solver_metadata["delay"] = delay
			
	def get_delay(self):
		"""Helper method for finding delay required
		"""
		delay = 13*self.pipelining 
		
		for d in self.derivative:
			for u in d.underlying:
				if("black_scholes" in u.name): delay = 25*self.pipelining
				if("heston" in u.name): delay = 176*self.pipelining
	
		return delay
