'''
Created on 30 October 2012

'''
import os,time,subprocess,sys,time,math
from ForwardFinancialFramework.Platforms.MulticoreCPU import MulticoreCPU_MonteCarlo

class MaxelerFPGA_MonteCarlo(MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo):
  def __init__(self,derivative,paths,platform,reduce_underlyings=True):
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.__init__(self,derivative,paths,platform,reduce_underlyings)
    
    self.solver_metadata["instances"] = self.platform.instances #Number of instances set by the platform
    self.solver_metadata["instance_paths"] = 1000 #setting the number of threads used per instance
    self.solver_metadata["path_points"] = 252
    self.iterations = int(self.solver_metadata["paths"]/self.solver_metadata["instance_paths"]) #calculating the number of iterations required of the kernel
    
    self.utility_libraries = ["stdio.h","stdlib.h","stdint.h","pthread.h","MaxCompilerRT.h"]
    
    self.activity_thread_name = "maxeler_montecarlo_activity_thread"
  
  def generate_identifier(self): return ["//%s.c Generated by Monte Carlo Maxeler Solver"%self.output_file_name]
  
  def generate(self,override=True):
    #Generate C Host Code largely using Multicore infrastructure
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate(self,"_Host_Code.c",override)
    
    #Generate Maxeler Kernel Code
    #self.generate_kernel()
    
    #Generate Maxeler HW Builder Code
    hw_builder_code_string = self.generate_hw_builder()
    self.generate_java_source(hw_builder_code_string,"_HW_Builder.java")
    
    #Generate Maxeler Makefile
    self.generate_makefile()
  
  def generate_activity_thread(self):
    output_list = []

    output_list.append("//*MC Maxeler Activity Thread Function*")
    output_list.append("void * %s(void* thread_arg){"%self.activity_thread_name)
    output_list.append("//**Creating Maxeler Variables, opening and configuring the FPGA**")
    output_list.append("char *device_name = (argc==2 ? argv[1] : NULL);") #TODO
    output_list.append("max_maxfile_t* maxfile;")
    output_list.append("max_device_handle_t* device;")
    output_list.append("maxfile = max_maxfile_init_%s();"%self.output_file_name)
    output_list.append("device = max_open_device(maxfile, device_name);")
    output_list.append("max_set_terminate_on_error(device);")
    
    output_list.append("//**Creating kernel IO variables, as well as generating random seeds to send to the FPGA**")
    output_list.append("uint32_t *seeds_in;")
    output_list.append("float *values_out;")
    
    seeds_in = math.ceil(float(len(self.underlying))/4) #Making sure seeds in is in increments of 128 bits
    #if(len(self.underlying)%4): seeds_in = seeds_in + (4-len(self.underlying)%4) #Making sure seeds in is in increments of 128 bits

    values_out = math.ceil(float(len(self.derivative))/4) #Making sure values are in increments of 128 bits
    #if(len(self.underlying)%4): values_out = values_out + (4-len(self.derivative)%4) #Making sure values are in increments of 128 bits
  
    output_list.append("posix_memalign(&seeds_in,%d,sizeof(uint32_t)*%d*iterations);"%(seeds_in*4,seeds_in))
    output_list.append("posix_memalign(&values_out,%d,sizeof(float)*%d*iterations);"%(values_out*4,values_out))
    output_list.append("uint32_t initial_seed = lrand48()%%(2**31-%d);"%(seeds_in*self.iterations)) #Start the seeds off at some random point
    output_list.append("for (i=0;i<%d;i++){"%(self.iterations*seeds_in)) #Quick way of creating many different seeds
    output_list.append("seeds_in[i] = initial_seed+i;")
    output_list.append("}")
    
    output_list.append("//**Streaming data to/from FPGA**")
    output_list.append("//***Setting Scaler(Parameters) Values***")
    output_list.append("//****Underlying Attributes****")
    index = 0
    for u_a in self.underlying_attributes:
        for a in u_a:
            attribute = "%s_%d_%s" % (self.underlying[index].name,index,a)
            output_list.append("max_set_scalar_input_f(device,\"%s_Kernel.%s\",%s,FPGA_A);"%(self.output_file_name,attribute,attribute))
        index += 1
    
    output_list.append("//****Derivative Attributes****")
    index = 0
    for o_a in self.derivative_attributes:
        for a in o_a:
            attribute = "%s_%d_%s" % (self.derivative[index].name,index,a)
            output_list.append("max_set_scalar_input_f(device,\"%s_Kernel.%s\",%s,FPGA_A);"%(self.output_file_name,attribute,attribute))
        index += 1
        
    output_list.append("//***Streaming IO Data to FPGA and Running Kernel***")
    output_list.append("max_run(device,")
    output_list.append("max_input(\"seeds_in\",seeds_in,%d*iterations*sizeof(uint32_t)),"%(seeds_in))
    output_list.append("max_output(\"values_out\", values_out, %d*iterations*sizeof(float)),"%(values_out))
    output_list.append("max_runfor(\"MC_Solver_Test_Kernel\",iterations*instance_paths*path_points),")
    output_list.append("max_end());")
    
    output_list.append("//**Post-Kernel Calculations**")
    for d in range(len(self.derivative)): output_list.append("double temp_total_%d=0;"%d)
    output_list.append("for(int i=0;i<%d;i++){"%(self.iterations))
    for d in self.derivative:
      index = self.derivative.index(d)
      output_list.append("temp_total_%d += values_out[i*%d+%d]/instance_paths;"%(index,values_out,index))
    output_list.append("}")
    output_list.append("//**Returning Result**")
    for d in self.derivative: output_list.append("temp_data->thread_result[%d] = temp_total_%d;"%(self.derivative.index(d),self.derivative.index(d)))
    output_list.append("}")
    
    return output_list
  
  def generate_libraries(self):
    output_list = ["//*Libraries"]
    output_list.append("#define __STDC_FORMAT_MACROS")
    for u in self.utility_libraries: output_list.append("#include \"%s\";"%u)
    
    return output_list
  
  def generate_kernel(self,overide=True):
    #Changing to code generation directory
    try:
      os.chdir("..")
      os.chdir(self.platform.platform_directory())
      
      #Checking that the source code for the derivative and underlying is present
      for u in self.underlying:
        if(not(os.path.exists("%s.java"%u.name))): raise IOError, ("missing the source code for the underlying - %s.java" % (u.name))
        if(not(os.path.exists("%s_parameters.java"%u.name))): raise IOError, ("missing the source code for the underlying parameter set - %s_parameters.java" % (u.name))
      for d in self.derivative:
        if(not(os.path.exists("%s.java"%d.name))): raise IOError, ("missing the source code for the derivative - %s.java" %  (d.name))
        if(not(os.path.exists("%s_parameters.java"%d.name))): raise IOError, ("missing the source code for the derivative parameter set - %s_parameters.java" %  (d.name))
      
      os.chdir(self.platform.root_directory)
      
    except:
      print "Maxeler Code directory doesn't exist!"
    
    os.chdir("bin")
    
  def generate_hw_builder(self):
    output_list = []
    
    #Package Declaration
    output_list.append("package mc_solver_prototype_maxeler;")
    
    #Maxeler Library imports
    output_list.append("import static config.BoardModel.BOARDMODEL;")
    output_list.append("import com.maxeler.maxcompiler.v1.kernelcompiler.Kernel;")
    output_list.append("import com.maxeler.maxcompiler.v1.managers.BuildConfig;")
    output_list.append("import com.maxeler.maxcompiler.v1.managers.standard.Manager;")
    output_list.append("import com.maxeler.maxcompiler.v1.managers.standard.Manager.IOType;")
    
    #Class declaration
    output_list.append("public class MC_Solver_Test_HW_Builder {")
    
    #Kernel Variable Setting
    output_list.append("private static int instance_paths = %d;"%self.solver_metadata["instance_paths"])
    output_list.append("private static int path_points = %d;"%self.solver_metadata["path_points"])
    output_list.append("private static int instances = %d;"%self.solver_metadata["instances"])
    
    #Main Method
    output_list.append("public static void main(String[] args) {")
    #Manager Declaration
    output_list.append("Manager m = new Manager(\"%s\", BOARDMODEL);"%self.output_file_name)
    #Kernel Declaration and parameter setting
    output_list.append("Kernel k = new MC_Solver_Test_Kernel(m.makeKernelParameters(\"%s_Kernel\"),instance_paths,path_points,instances);"%self.output_file_name)
    output_list.append("m.setKernel(k);")
    output_list.append("m.setIO(IOType.ALL_PCIE);")
    output_list.append("m.addMaxFileConstant(\"instance_paths\", instance_paths);")
    output_list.append("m.addMaxFileConstant(\"path_points\", path_points);")
    output_list.append("m.addMaxFileConstant(\"instances\", instances);")
    output_list.append("m.setClockFrequency(100);")
    #Build Configuration
    output_list.append("BuildConfig c = new BuildConfig(BuildConfig.Level.FULL_BUILD);")
    output_list.append("c.setBuildEffort(BuildConfig.Effort.MEDIUM);")  #LOW,MEDIUM,HIGH,VERY_HIGH
    output_list.append("c.setEnableTimingAnalysis(true);")
    output_list.append("c.setMPPRCostTableSearchRange(1,100);")
    output_list.append("c.setMPPRParallelism(10);")
    output_list.append("m.setBuildConfig(c);")
    output_list.append("m.build();")
    output_list.append("}")#Closing off Main Method
    output_list.append("}")#Closing off Class decleration
    
    return output_list
  
  def generate_makefile(self):
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    makefile = open("Makefile","w")
    makefile.write("BASEDIR=../..\n")
    makefile.write("PACKAGE=MaxelerFPGA_MonteCarlo\n")
    makefile.write("APP=%s\n"%self.output_file_name)
    makefile.write("HWMAXFILE=$(APP).max\n")
    #makefile.write("HOSTSIMMAXFILE=$(APP)_Host_Sim.max")
    makefile.write("HWBUILDER=$(APP)_HW_Builder.java\n")
    #makefile.write("HOSTSIMBUILDER=$(APP)_Host_Sim_Builder.java")
    #makefile.write("SIMRUNNER=$(APP)_Sim_Runner.java")
    makefile.write("HOSTCODE=$(APP)_Host_Code.c\n")
    makefile.write("KERNELCODE=$(APP)_Kernel.java\n\n")
    
    makefile.write("nullstring :=\n")
    makefile.write("space := $(nullstring)\n")
    makefile.write("MAXCOMPILERDIR_QUOTE:=$(subst $(space),\ ,$(MAXCOMPILERDIR))\n")
    makefile.write("include $(MAXCOMPILERDIR_QUOTE)/lib/Makefile.include\n")
    makefile.write("ifndef MAXCOMPILERDIR\n")
    makefile.write("\t$(error MAXCOMPILERDIR environment variable is not set)\n")
    makefile.write("endif\n")
    makefile.write("nullstring :=\n")
    makefile.write("space := $(nullstring) # a space at the end\n")
    makefile.write("MAXCOMPILERDIR_QUOTE:=$(subst $(space),\\ ,$(MAXCOMPILERDIR))\n")
    makefile.write("include $(MAXCOMPILERDIR)/lib/Makefile.include\n")
    makefile.write("include $(MAXCOMPILERDIR_QUOTE)/examples/common/Makefile.include\n")
    makefile.close()
    
    os.chdir(self.platform.root_directory())
    os.chdir("bin")
    
  """def generate_java_source(self,code_string,name_extension=""):
    os.chdir("..")
    os.chdir(self.platform.platform_directory())
    
    output_file = open("%s%s.java"%(self.output_file_name,name_extension),"w")
    tab_count = 0;
    for c_s in code_string:
        if("*" in c_s and "//" in c_s): output_file.write("\n") #Insert a blank line if the line is a comment section
        for i in range(tab_count): output_file.write("\t")	#Tabify the code
        output_file.write("%s\n"%c_s)
            
        if("{" in c_s): tab_count = tab_count+1
        if("}" in c_s): tab_count = max(tab_count-1,0)
    output_file.close()
    
    os.chdir(self.platform.root_directory())
    os.chdir("bin")"""