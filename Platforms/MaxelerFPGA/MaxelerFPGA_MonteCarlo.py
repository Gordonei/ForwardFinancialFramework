'''
Created on 30 October 2012

'''
import os,time,subprocess,sys,time,math
from ForwardFinancialFramework.Platforms.MulticoreCPU import MulticoreCPU_MonteCarlo

class MaxelerFPGA_MonteCarlo(MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo):
  def __init__(self,derivative,paths,platform,reduce_underlyings=True):
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.__init__(self,derivative,paths,platform,reduce_underlyings)
    
    self.solver_metadata["instances"] = self.platform.instances #Number of instances set by the platform
    self.solver_metadata["instance_paths"] = 1000 #setting the number of threads used per instance
    self.solver_metadata["path_points"] = 252
    self.iterations = int(self.solver_metadata["paths"]/self.solver_metadata["instance_paths"]) #calculating the number of iterations required of the kernel
    
    self.utility_libraries = ["stdio.h","stdlib.h","stdint.h","pthread.h","MaxCompilerRT.h"]
    
    self.activity_thread_name = "maxeler_montecarlo_activity_thread"
  
  def generate_identifier(self): return ["//%s.c Generated by Monte Carlo Maxeler Solver"%self.output_file_name]
  
  def generate(self,override=True):
    #Generate C Host Code largely using Multicore infrastructure
    MulticoreCPU_MonteCarlo.MulticoreCPU_MonteCarlo.generate(self,override)
    
    #Generate Maxeler Kernel Code
    #self.generate_kernel()
    
    #Generate Maxeler HW Builder Code
    #self.generate_hw_builder()
    
    #Generate Maxeler Makefile
    #self.generate_makefile()
  
  def generate_activity_thread(self):
    output_list = []

    output_list.append("//*MC Maxeler Activity Thread Function*")
    output_list.append("void * %s(void* thread_arg){"%self.activity_thread_name)
    output_list.append("//**Creating Maxeler Variables, opening and configuring the FPGA**")
    output_list.append("char *device_name = (argc==2 ? argv[1] : NULL);") #TODO
    output_list.append("max_maxfile_t* maxfile;")
    output_list.append("max_device_handle_t* device;")
    output_list.append("maxfile = max_maxfile_init_%s();"%self.output_file_name)
    output_list.append("device = max_open_device(maxfile, device_name);")
    output_list.append("max_set_terminate_on_error(device);")
    
    output_list.append("//**Creating kernel IO variables, as well as generating random seeds to send to the FPGA**")
    output_list.append("uint32_t *seeds_in;")
    output_list.append("float *values_out;")
    
    seeds_in = math.ceil(float(len(self.underlying))/4)
    #if(len(self.underlying)%4): seeds_in = seeds_in + (4-len(self.underlying)%4) #Making sure seeds in is in increments of 128 bits

    values_out = math.ceil(float(len(self.derivative))/4)
    #if(len(self.underlying)%4): values_out = values_out + (4-len(self.derivative)%4) #Making sure values are in increments of 128 bits
  
    output_list.append("posix_memalign(&seeds_in,%d,sizeof(uint32_t)*%d);"%(seeds_in*4,seeds_in*self.iterations))
    output_list.append("posix_memalign(&values_out,%d,sizeof(float)*%d);"%(values_out*4,values_out*self.iterations))
    output_list.append("uint32_t initial_seed = lrand48()%%(2**31-%d);"%(seeds_in*self.iterations)) #Start the seeds off at some random point
    output_list.append("for (i=0;i<%d;i++){"%(self.iterations*seeds_in)) #Quick way of creating many different seeds
    output_list.append("seeds_in[i] = initial_seed+i;")
    output_list.append("}")
    
    output_list.append("//**Streaming data to/from FPGA**")
    output_list.append("//***Setting Scaler(Parameters) Values***")
    output_list.append("//****Underlying Attributes****")
    index = 0
    for u_a in self.underlying_attributes:
        for a in u_a:
            attribute = "%s_%d_%s" % (self.underlying[index].name,index,a)
            output_list.append("max_set_scalar_input_f(device,\"%s_Kernel.%s\",%s,FPGA_A);"%(self.output_file_name,attribute,attribute))
        index += 1
    
    output_list.append("//****Derivative Attributes****")
    index = 0
    for o_a in self.derivative_attributes:
        for a in o_a:
            attribute = "%s_%d_%s" % (self.derivative[index].name,index,a)
            output_list.append("max_set_scalar_input_f(device,\"%s_Kernel.%s\",%s,FPGA_A);"%(self.output_file_name,attribute,attribute))
        index += 1
        
    output_list.append("//***Streaming IO Data to FPGA and Running Kernel***")
    output_list.append("max_run(device,")
    output_list.append("max_input(\"seeds_in\",seeds_in,%d*iterations*sizeof(uint32_t)),"%(seeds_in))
    output_list.append("max_output(\"values_out\", values_out, %d*iterations*sizeof(float)),"%(values_out))
    output_list.append("max_runfor(\"MC_Solver_Test_Kernel\",iterations*instance_paths*path_points),")
    output_list.append("max_end());")
    
    output_list.append("//**Post-Kernel Calculations**")
    for d in range(len(self.derivative)): output_list.append("double temp_total_%d=0;"%d)
    output_list.append("for(int i=0;i<%d;i++){"%(self.iterations))
    for d in self.derivative:
      index = self.derivative.index(d)
      output_list.append("temp_total_%d += values_out[i*%d+%d]/instance_paths;"%(index,values_out,index))
    output_list.append("}")
    output_list.append("//**Returning Result**")
    for d in self.derivative: output_list.append("temp_data->thread_result[%d] = temp_total_%d;"%(self.derivative.index(d),self.derivative.index(d)))
    
    output_list.append("}")
    
    return output_list
  
  def generate_libraries(self):
    output_list = ["//*Libraries"]
    output_list.append("#define __STDC_FORMAT_MACROS")
    for u in self.utility_libraries: output_list.append("#include \"%s\";"%u)
    
    return output_list
  
  def generate_kernel(self,overide=True):
    #Changing to code generation directory
    try:
      os.chdir("..")
      os.chdir(self.platform.platform_directory())
      
      #Checking that the source code for the derivative and underlying is present
      for u in self.underlying:
        if(not(os.path.exists("%s.java"%u.name))): raise IOError, ("missing the source code for the underlying - %s.java" % (u.name))
        if(not(os.path.exists("%s_parameters.java"%u.name))): raise IOError, ("missing the source code for the underlying parameter set - %s_parameters.java" % (u.name))
      for d in self.derivative:
        if(not(os.path.exists("%s.java"%d.name))): raise IOError, ("missing the source code for the derivative - %s.java" %  (d.name))
        if(not(os.path.exists("%s_parameters.java"%d.name))): raise IOError, ("missing the source code for the derivative parameter set - %s_parameters.java" %  (d.name))
      
      os.chdir(self.platform.root_directory)
      
    except:
      print "Maxeler Code directory doesn't exist!"
    
    os.chdir("bin")
    
  def generate_hw_builder(self): pass
  
  def generate_makefile(self): pass