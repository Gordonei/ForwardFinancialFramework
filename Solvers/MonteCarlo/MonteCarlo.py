'''
Created on 11 July 2012

'''
import os,time,subprocess,sys,time,math

class MonteCarlo:
    name = "monte_carlo_solver"
    paths = None
    threads = None
    
    platforms = []
    
    derivative = []
    derivative_attributes = []
    derivative_variables = []
    
    underlying = []
    underlying_attributes = []
    underlying_variables = []
    underlying_dependencies = []
    
    def __init__(self,derivative,paths,platform,reduce_underlyings=True):
        name = "monte_carlo_solver"
        self.platform = platform
        self.paths = paths
           
	self.solver_metadata = {"paths":self.paths} 
        self.derivative = derivative
        self.underlying = []
        for d in self.derivative:
            for u in d.underlying:
                temp_underlying_dict = []
                for uu in self.underlying: temp_underlying_dict.append(uu.__dict__)
                if(u.__dict__ not in temp_underlying_dict and reduce_underlyings):  self.underlying.append(u) #Extracting unique underlyings from derivatives
                elif(reduce_underlyings):  #Making sure that equal underlyings are merged - TODO make this check stronger
                    index = derivative.index(d)
                    u_index = d.underlying.index(u)
                    new_u_index = temp_underlying_dict.index(u.__dict__)
                    d.underlying[u_index] = self.underlying[new_u_index]
                
                    u_index = self.underlying.index(uu)
                    
                if((len(self.underlying)==0) or not reduce_underlyings): self.underlying.append(u)
         
        temp = [] #Generating Filename - based on underlyings,derivatives and platforms used
        self.output_file_name = "mc_solver"
        
        self.output_file_name = ("%s_%s"%(self.output_file_name,self.platform.name))
	  
        for u in self.underlying:
          if u.name not in temp:
            count = 0
            for uu in self.underlying:
              if(uu.name==u.name): count = count + 1
    
            self.output_file_name = "%s_%s_%d" % (self.output_file_name,u.name[0],count) #First letter is used to keep names succinct
            temp.append(u.name)
    
        for d in self.derivative: 
          if d.name not in temp:
            count = 0
            for dd in self.derivative:
              if(dd.name==d.name): count = count + 1
      
            self.output_file_name = "%s_%s_%d" % (self.output_file_name,d.name[0],count)
            temp.append(d.name)
        
        self.underlying_dependencies = [] #Creating a dependency list for each underlying, detailing the derivative that depends on it
        for u in self.underlying:
            self.underlying_dependencies.append([])
            for d in self.derivative:
                if(u in d.underlying): self.underlying_dependencies[-1].append(self.derivative.index(d))

        #Extracting variables and attributes required during code generation, compilation and execution process
        self.underlying_attributes = []
        self.underlying_variables = []
        for u in self.underlying:
            self.underlying_attributes.append(u.__init__.__code__.co_varnames[1:])
            self.underlying_variables.append(self.attribute_stripper(self.underlying_attributes[-1],u.path_init.__code__.co_names))

        self.derivative_attributes = []
        self.derivative_variables = []
        for d in self.derivative:
            self.derivative_attributes.append(list(d.__init__.__code__.co_varnames[1:]))
            self.derivative_attributes[-1].remove("underlying")
            self.derivative_attributes[-1] = tuple(self.derivative_attributes[-1])
            self.derivative_variables.append(self.attribute_stripper(self.derivative_attributes[-1],d.path_init.__code__.co_names))
    
    def generate(self,override=True):
	os.chdir("..")
	os.chdir(self.platform.platform_directory())
	
	if(override or not os.path.exists("%s.c"%self.output_file_name)):
	    code_string = []
	    code_string.extend(self.generate_identifier())
	    code_string.extend(self.generate_libraries())
	    code_string.extend(self.generate_variable_declaration())
	    code_string.extend(self.generate_activity_thread())
	    code_string.extend(self.generate_main_thread())
	    
	    #Actually writing to the file
	    output_file = open("%s.c"%self.output_file_name,"w")
	    tab_count = 0;
	    for c_s in code_string:
		if("*" in c_s and "//" in c_s): output_file.write("\n")
		for i in range(tab_count): output_file.write("\t")	
		output_file.write("%s\n"%c_s)
		
		if("{" in c_s): tab_count = tab_count+1
		if("}" in c_s): tab_count = max(tab_count-1,0)
	    output_file.close()
	    
	os.chdir(self.platform.root_directory())
	os.chdir("bin")
	
    def compile(self): pass
    
    def execute(self): pass
    
    def generate_identifier(self): return ["//%s.c Generated by Monte Carlo Solver"%self.output_file_name]
    
    def generate_libraries(self): pass
    
    def generate_variable_declaration(self): pass
    
    def generate_activity_thread(self): pass
    
    def generate_main_thread(self): pass
    
    def attribute_stripper(self,attributes,variables):
        """Helper Method used to remove all items in the first list from the second list, if present """
        variables = list(variables)
        for a in attributes:
            if(variables.count(a)): variables.remove(a)
        
        return tuple(variables)
    