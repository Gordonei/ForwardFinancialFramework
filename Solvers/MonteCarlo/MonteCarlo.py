'''
Created on 11 July 2012

'''
import os,time,subprocess,sys,time,math

class MonteCarlo:
    name = "monte_carlo_solver"
    paths = None
    threads = None
    
    platforms = []
    
    derivative = []
    derivative_attributes = []
    derivative_variables = []
    
    underlying = []
    underlying_attributes = []
    underlying_variables = []
    underlying_dependencies = []
    
    def __init__(self,derivative,paths,platform,reduce_underlyings=True):
        name = "monte_carlo_solver"
        self.platform = platform
        self.paths = paths
        
        #if(self.platform.name=="multicore_cpu"):   
            #self.non_system_libraries = ["memory_used"]
            #self.solver_metadata = {"paths":self.paths,"threads":self.platform.threads}
            
        self.derivative = derivative
        self.underlying = []
        for d in self.derivative:
            for u in d.underlying:
                temp_underlying_dict = []
                for uu in self.underlying: temp_underlying_dict.append(uu.__dict__)
                if(u.__dict__ not in temp_underlying_dict and reduce_underlyings):  self.underlying.append(u) #Extracting unique underlyings from derivatives
                elif(reduce_underlyings):  #Making sure that equal underlyings are merged - TODO make this check stronger
                    index = derivative.index(d)
                    u_index = d.underlying.index(u)
                    new_u_index = temp_underlying_dict.index(u.__dict__)
                    d.underlying[u_index] = self.underlying[new_u_index]
                
                    u_index = self.underlying.index(uu)
                    
                if((len(self.underlying)==0) or not reduce_underlyings): self.underlying.append(u)
         
        temp = [] #Generating Filename - based on underlyings,derivatives and platforms used
        self.output_file_name = "mc_solver"
        
        for p in self.platforms: self.output_file_name = ("%s_%s"%(self.output_file_name,p.name))
	  
        for u in self.underlying:
          if u.name not in temp:
            count = 0
            for uu in self.underlying:
              if(uu.name==u.name): count = count + 1
    
            self.output_file_name = "%s_%s_%d" % (self.output_file_name,u.name[0],count) #First letter is used to keep names succinct
            temp.append(u.name)
    
        for d in self.derivative: 
          if d.name not in temp:
            count = 0
            for dd in self.derivative:
              if(dd.name==d.name): count = count + 1
      
            self.output_file_name = "%s_%s_%d" % (self.output_file_name,d.name[0],count)
            temp.append(d.name)
        
        self.underlying_dependencies = [] #Creating a dependency list for each underlying, detailing the derivative that depends on it
        for u in self.underlying:
            self.underlying_dependencies.append([])
            for d in self.derivative:
                if(u in d.underlying): self.underlying_dependencies[-1].append(self.derivative.index(d))

        #Extracting variables and attributes required during code generation and execution process
        self.underlying_attributes = []
        self.underlying_variables = []
        for u in self.underlying:
            self.underlying_attributes.append(u.__init__.__code__.co_varnames[1:])
            self.underlying_variables.append(self.attribute_stripper(self.underlying_attributes[-1],u.path_init.__code__.co_names))

        self.derivative_attributes = []
        self.derivative_variables = []
        for d in self.derivative:
            self.derivative_attributes.append(list(d.__init__.__code__.co_varnames[1:]))
            self.derivative_attributes[-1].remove("underlying")
            self.derivative_attributes[-1] = tuple(self.derivative_attributes[-1])
            self.derivative_variables.append(self.attribute_stripper(self.derivative_attributes[-1],d.path_init.__code__.co_names))
    
    def generate(self,override=True):
	if(overide or not os.path.exists("%s.c"%self.output_file_name))
	    code_string = []
	    code_string.extend(self.generate_identifier)
	    code_string.extend(self.generate_libraries)
	    code_string.extend(self.generate_variable_declaration)
	    code_string.extend(self.generate_main_thread)
	    
	    output_file = open(self.output_file_name,"w")
	    tab_count = 0;
	    for c_s in code_string:
		for i in range(tab_count): output_file.write("\t")	
		output_file.write("%s\n"%c_s)
		
		if(c_s.contains("{")):
		    tab_count = tab_count+1
		elif(c_s.contains("}"))
		    tab_count = max(tab_count-1,0)
	
    def compile(self):
	pass
    
    def execute(self):
        pass
    
    def generate_identifier(self):
	return ["//Generated by Monte Carlo Solver\n"]
    
    def generate_libraries(self):
	
	output_list = ["//Libraries"]
	utility_libraries = ["math.h","pthread.h","stdint.h","stdlib.h","stdio.h","sys/time.h","sys/resource.h","unistd.h"]
	for u in utility_libraries: output_list.append("include \"%s\";")
	output_list.extend(utility_libraries)
	
	return output_list
    
    def generate_variable_declaration(self):
	#Generate Intermediate and Communication Variables
	output_list = []
	output_list.append("//*Intermediate and Communication Variables*")
	
	for d in self.derivative:
	    index = self.derivative.index(d)
	    for u in d.underlying:
		u_index = self.underlying.index(u)
		output_list.append("double discount_%d_%d;"%(index,u_index))
		
	    output_list.append("double option_price_%d;"%index)
	    
	index = 0
	for u_a in self.underlying_attributes:
	    for a in u_a: output_list.append("static double %s_%d_%s;"%(self.underlying[index].name,index,a)) #execution code must mirror this ordering
	    index += 1
	
	index = 0
	for o_a in self.derivative_attributes:
	    for o in o_a: output_list.append("static double %s_%d_%s;"%(self.derivative[index].name,index,o)) #execution code must mirror this ordering
	    index += 1
	    
	for k in self.solver_metadata.keys(): output_list.append("static int %s;"%k) 
	    
	output_list.append("int thread_paths,i,j;")
	
	output_list.append("struct thread_data{")
	#output_list.append("int thread_paths;")
	output_list.append("double *thread_result;")
	output_list.append("}")
	
	#Performance Monitoring Variables
	output_file.write("//\t*Performance Monitoring Variables*")
	output_file.write("double system_time,user_time,cpu_time,wall_time;")
	output_file.write("struct timeval start, end;")
	output_file.write("int ret,ret_2;")
	output_file.write("struct rusage usage,usage_2;")
    
    def generate_activity_thread(self): pass
    
    def generate_main_thread(self):
	output_list = []
	
	#Declare Main Function
	output_list.append("//*Main Function*")
	output_list.append("int main(int argc,char* argv[]){")
	##Commented out diagnostic tool
	#output_file.write("\t/*for(i=0;i<argc;i++){//For diagnostic Purposes\n\t\tprintf(\"%s \",argv[i]);\n\t}*/\n")
	
	##Convert command line arguments to static variables
	output_list.append("//**Unpacking Command Line Variables**")
	temp = 1
	output_list.append.write("//\t***Solver Metadata***\n")
	for k in self.solver_metadata.keys(): 
	    output_list.append.write("\t%s = atoi(argv[%d]);\n"%(k,temp))
	    temp += 1
	
	output_file.write("//\t***Underlying Attributes***\n")
	index = 0
	for u_a in self.underlying_attributes:
	    for a in u_a:
		output_list.append("\t%s_%d_%s = strtod(argv[%d],NULL);\n"%(self.underlying[index].name,index,a,temp))
		temp += 1
	    output_list.append("\n")
	    index += 1
	
	output_list.append("//\t***Derivative Attributes***\n")
	index = 0
	for o_a in self.derivative_attributes:
	    for a in o_a:
		output_list.append("\t%s_%d_%s = strtod(argv[%d],NULL);\n"%(self.derivative[index].name,index,a,temp))
		temp += 1
	    output_list.append("\n")
	    index += 1
	    
	output_list.append("//\t**Starting Timers**\n")
	output_list.append("\tint who = RUSAGE_SELF;\n")
	output_list.append("\tgettimeofday(&start,NULL);\n")
	output_list.append("\tret=getrusage(who,&usage);\n")
	
	##Calculate Discount Factor
	output_list.append("//\t**Calculating Discount Factor**\n")
	
	for d in self.derivative:
	    index = self.derivative.index(d)
	    for u in d.underlying:
		u_index = self.underlying.index(u)
		output_list.append("\tdiscount_%d_%d = exp(-%s_%d_rfir*%s_%d_time_period);\n"%(index,u_index,u.name,u_index,d.name,index))
		
	output_list.append("\n")
	
	##Create Thread Support Structure
	output_list.append("//\t**Creating Thread Variables**\n")
	output_list.append("\tthread_paths = paths/threads;\n")
	output_list.append("\tpthread_t pthreads[threads];\n")
	output_list.append("\tdouble thread_results[threads][%d];\n"%len(self.derivative))
	output_list.append("\tstruct thread_data temp_data[threads];\n")
	
	output_list.append("\tpthread_attr_t attr;\n")
	output_list.append("\tpthread_attr_init(&attr);\n")
	output_list.append("\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n")
	output_list.append("\n")
	
	##Pack up data and pass to threads
	output_list.append("//\t**Packing up data and passing to threads**\n")
	output_list.append("\tint i;\n");
	output_list.append("\tfor(i=0;i<threads;i++){ //Generating Threads\n");
	output_list.append("\t\ttemp_data[i].thread_paths = thread_paths;\n")
	output_list.append("\t\tif(i==(threads-1)){ //If final thread, allocating any remaining paths to it (i.e. PATHS%THREADS!=0)\n")
	output_list.append("\t\t\ttemp_data[i].thread_paths += paths%threads;\n")
	output_list.append("\t\t}\n")
	output_list.append("\t\ttemp_data[i].thread_result = thread_results[i];\n")
	output_list.append("\t\tpthread_create(&pthreads[i],&attr,path_loop,&temp_data[i]);\n")
	output_list.append("\t}\n")
	output_list.append("\n")
	##Join Threads, aggregate results
	output_list.append("//\t**Waiting for threads to join**\n")
	output_list.append("\tvoid *status;\n")
	for d in self.derivative: output_list.append("\toption_price_%d = 0;\n"%self.derivative.index(d))
	output_list.append("\tfor(i=0;i<threads;i++){ //Waiting for Threads\n");
	output_list.append("\t\tpthread_join(pthreads[i],&status);\n");
	
	for d in self.derivative:
	    index = self.derivative.index(d)
	    for u in d.underlying:
		u_index = self.underlying.index(u)
		output_list.append("\t\toption_price_%d += discount_%d_%d*thread_results[i][%d];\n"%(index,index,u_index,index));
		#output_file.write("\t\toption_price_%d = thread_results[i][%d];\n"%(index,index));
	
	output_list.append("\t}\n")
	output_list.append("\n")
	
	##Calculate final value and return value
	output_list.append("//\t**Calculating Final Option Value and Return**\n")
	for d in self.derivative:
	    output_list.append("\toption_price_%d = option_price_%d/paths;//Calculate final value and return value as well as timing\n"%(self.derivative.index(d),self.derivative.index(d)))
	    output_list.append("\tprintf(\"\%f\\n\"")
	    output_list.append(",option_price_%d);\n"%self.derivative.index(d))
	
	##Return Performance evaluation
	output_list.append("//\t**Performance Monitoring Calculation and Return**\n")
	output_list.append("\tgettimeofday(&end,NULL);\n")
	output_list.append("\tret_2=getrusage(who,&usage_2);\n")
	
	output_list.append("\tuser_time = usage_2.ru_utime.tv_sec*1000000+usage_2.ru_utime.tv_usec-(usage.ru_utime.tv_sec*1000000+usage.ru_utime.tv_usec);\n")
	output_list.append("\tsystem_time = usage_2.ru_stime.tv_sec*1000000+usage_2.ru_stime.tv_usec-(usage.ru_stime.tv_sec*1000000+usage.ru_stime.tv_usec);\n")
	output_list.append("\tcpu_time = (user_time + system_time);\n")
	output_list.append("\twall_time = 1000000*(end.tv_sec-start.tv_sec)+end.tv_usec-start.tv_usec;\n")
	
	output_list.append("\tprintf(\"\%f\\n\",cpu_time);\n")
	output_list.append("\tprintf(\"\%f\\n\",wall_time);\n")
	output_list.append("\tprintf(\"\%d\\n\",(MemoryUsed()));\n")
	
	output_list.append("}\n")
	output_list.append("\n")
	
	return output_list
    
    def attribute_stripper(self,attributes,variables):
        """Helper Method used to remove all items in the first list from the second list, if present """
        variables = list(variables)
        for a in attributes:
            if(variables.count(a)): variables.remove(a)
        
        return tuple(variables)
    
    def generate_base_class_names(self,tempclass,templist):
      """Another Helper Method, uses to help pull in various super classes during compilation """
      if(tempclass.name not in templist): templist.append(tempclass.name)
      for b in tempclass.__bases__: self.generate_base_class_names(b,templist)